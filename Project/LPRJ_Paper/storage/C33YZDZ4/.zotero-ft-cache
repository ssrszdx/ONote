PostgreSQL 16.2 Documentation
The PostgreSQL Global Development Group


PostgreSQL 16.2 Documentation
The PostgreSQL Global Development Group Copyright © 1996–2024 The PostgreSQL Global Development Group
Legal Notice
PostgreSQL is Copyright © 1996–2024 by the PostgreSQL Global Development Group.
Postgres95 is Copyright © 1994–5 by the Regents of the University of California.
Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN “AS-IS” BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.


Table of Contents
Preface ................................................................................................................... xxxii 1. What Is PostgreSQL? .................................................................................... xxxii 2. A Brief History of PostgreSQL ....................................................................... xxxii 2.1. The Berkeley POSTGRES Project ........................................................ xxxiii 2.2. Postgres95 ....................................................................................... xxxiii 2.3. PostgreSQL ...................................................................................... xxxiv 3. Conventions ................................................................................................ xxxiv 4. Further Information ...................................................................................... xxxiv 5. Bug Reporting Guidelines .............................................................................. xxxv 5.1. Identifying Bugs ................................................................................ xxxv 5.2. What to Report ................................................................................. xxxvi 5.3. Where to Report Bugs ....................................................................... xxxvii I. Tutorial .................................................................................................................... 1 1. Getting Started .................................................................................................. 3 1.1. Installation ............................................................................................. 3 1.2. Architectural Fundamentals ....................................................................... 3 1.3. Creating a Database ................................................................................. 3 1.4. Accessing a Database .............................................................................. 5 2. The SQL Language ............................................................................................ 7 2.1. Introduction ............................................................................................ 7 2.2. Concepts ................................................................................................ 7 2.3. Creating a New Table .............................................................................. 7 2.4. Populating a Table With Rows .................................................................. 8 2.5. Querying a Table .................................................................................... 9 2.6. Joins Between Tables ............................................................................. 11 2.7. Aggregate Functions .............................................................................. 13 2.8. Updates ............................................................................................... 15 2.9. Deletions .............................................................................................. 15 3. Advanced Features ........................................................................................... 17 3.1. Introduction .......................................................................................... 17 3.2. Views .................................................................................................. 17 3.3. Foreign Keys ........................................................................................ 17 3.4. Transactions ......................................................................................... 18 3.5. Window Functions ................................................................................. 20 3.6. Inheritance ........................................................................................... 23 3.7. Conclusion ........................................................................................... 24 II. The SQL Language ................................................................................................. 25 4. SQL Syntax .................................................................................................... 33 4.1. Lexical Structure ................................................................................... 33 4.2. Value Expressions ................................................................................. 42 4.3. Calling Functions .................................................................................. 56 5. Data Definition ................................................................................................ 59 5.1. Table Basics ......................................................................................... 59 5.2. Default Values ...................................................................................... 60 5.3. Generated Columns ................................................................................ 61 5.4. Constraints ........................................................................................... 62 5.5. System Columns ................................................................................... 71 5.6. Modifying Tables .................................................................................. 72 5.7. Privileges ............................................................................................. 75 5.8. Row Security Policies ............................................................................ 80 5.9. Schemas ............................................................................................... 86 5.10. Inheritance .......................................................................................... 90 5.11. Table Partitioning ................................................................................ 94 5.12. Foreign Data ..................................................................................... 108 5.13. Other Database Objects ....................................................................... 108
iii


PostgreSQL 16.2 Documentation
5.14. Dependency Tracking ......................................................................... 108 6. Data Manipulation .......................................................................................... 111 6.1. Inserting Data ..................................................................................... 111 6.2. Updating Data ..................................................................................... 112 6.3. Deleting Data ...................................................................................... 113 6.4. Returning Data from Modified Rows ....................................................... 113 7. Queries ......................................................................................................... 115 7.1. Overview ............................................................................................ 115 7.2. Table Expressions ................................................................................ 115 7.3. Select Lists ......................................................................................... 131 7.4. Combining Queries (UNION, INTERSECT, EXCEPT) ................................ 133 7.5. Sorting Rows (ORDER BY) .................................................................. 134 7.6. LIMIT and OFFSET ............................................................................ 135 7.7. VALUES Lists ..................................................................................... 135 7.8. WITH Queries (Common Table Expressions) ............................................ 136 8. Data Types .................................................................................................... 146 8.1. Numeric Types .................................................................................... 147 8.2. Monetary Types ................................................................................... 153 8.3. Character Types ................................................................................... 153 8.4. Binary Data Types ............................................................................... 156 8.5. Date/Time Types ................................................................................. 158 8.6. Boolean Type ...................................................................................... 167 8.7. Enumerated Types ............................................................................... 168 8.8. Geometric Types ................................................................................. 170 8.9. Network Address Types ........................................................................ 173 8.10. Bit String Types ................................................................................ 175 8.11. Text Search Types .............................................................................. 176 8.12. UUID Type ....................................................................................... 179 8.13. XML Type ........................................................................................ 179 8.14. JSON Types ...................................................................................... 181 8.15. Arrays .............................................................................................. 191 8.16. Composite Types ............................................................................... 201 8.17. Range Types ..................................................................................... 207 8.18. Domain Types ................................................................................... 213 8.19. Object Identifier Types ....................................................................... 214 8.20. pg_lsn Type ................................................................................... 216 8.21. Pseudo-Types .................................................................................... 217 9. Functions and Operators .................................................................................. 219 9.1. Logical Operators ................................................................................ 219 9.2. Comparison Functions and Operators ...................................................... 220 9.3. Mathematical Functions and Operators .................................................... 224 9.4. String Functions and Operators .............................................................. 231 9.5. Binary String Functions and Operators .................................................... 241 9.6. Bit String Functions and Operators ......................................................... 245 9.7. Pattern Matching ................................................................................. 247 9.8. Data Type Formatting Functions ............................................................. 266 9.9. Date/Time Functions and Operators ........................................................ 274 9.10. Enum Support Functions ..................................................................... 290 9.11. Geometric Functions and Operators ....................................................... 291 9.12. Network Address Functions and Operators .............................................. 298 9.13. Text Search Functions and Operators ..................................................... 301 9.14. UUID Functions ................................................................................ 308 9.15. XML Functions ................................................................................. 308 9.16. JSON Functions and Operators ............................................................. 322 9.17. Sequence Manipulation Functions ......................................................... 342 9.18. Conditional Expressions ...................................................................... 343 9.19. Array Functions and Operators ............................................................. 346 9.20. Range/Multirange Functions and Operators ............................................. 350
iv


PostgreSQL 16.2 Documentation
9.21. Aggregate Functions ........................................................................... 356 9.22. Window Functions ............................................................................. 363 9.23. Subquery Expressions ......................................................................... 365 9.24. Row and Array Comparisons ............................................................... 367 9.25. Set Returning Functions ...................................................................... 370 9.26. System Information Functions and Operators .......................................... 374 9.27. System Administration Functions .......................................................... 393 9.28. Trigger Functions ............................................................................... 410 9.29. Event Trigger Functions ...................................................................... 411 9.30. Statistics Information Functions ............................................................ 414 10. Type Conversion .......................................................................................... 416 10.1. Overview .......................................................................................... 416 10.2. Operators .......................................................................................... 417 10.3. Functions .......................................................................................... 421 10.4. Value Storage .................................................................................... 425 10.5. UNION, CASE, and Related Constructs .................................................. 426 10.6. SELECT Output Columns .................................................................... 427 11. Indexes ....................................................................................................... 429 11.1. Introduction ....................................................................................... 429 11.2. Index Types ...................................................................................... 430 11.3. Multicolumn Indexes .......................................................................... 432 11.4. Indexes and ORDER BY ..................................................................... 433 11.5. Combining Multiple Indexes ................................................................ 434 11.6. Unique Indexes .................................................................................. 435 11.7. Indexes on Expressions ....................................................................... 435 11.8. Partial Indexes ................................................................................... 436 11.9. Index-Only Scans and Covering Indexes ................................................ 439 11.10. Operator Classes and Operator Families ................................................ 441 11.11. Indexes and Collations ...................................................................... 443 11.12. Examining Index Usage ..................................................................... 443 12. Full Text Search ........................................................................................... 445 12.1. Introduction ....................................................................................... 445 12.2. Tables and Indexes ............................................................................. 449 12.3. Controlling Text Search ...................................................................... 451 12.4. Additional Features ............................................................................ 458 12.5. Parsers ............................................................................................. 464 12.6. Dictionaries ....................................................................................... 465 12.7. Configuration Example ....................................................................... 475 12.8. Testing and Debugging Text Search ...................................................... 476 12.9. Preferred Index Types for Text Search ................................................... 481 12.10. psql Support .................................................................................... 482 12.11. Limitations ...................................................................................... 485 13. Concurrency Control ..................................................................................... 486 13.1. Introduction ....................................................................................... 486 13.2. Transaction Isolation ........................................................................... 486 13.3. Explicit Locking ................................................................................ 492 13.4. Data Consistency Checks at the Application Level ................................... 498 13.5. Serialization Failure Handling .............................................................. 499 13.6. Caveats ............................................................................................. 500 13.7. Locking and Indexes ........................................................................... 500 14. Performance Tips ......................................................................................... 502 14.1. Using EXPLAIN ................................................................................ 502 14.2. Statistics Used by the Planner .............................................................. 514 14.3. Controlling the Planner with Explicit JOIN Clauses ................................. 519 14.4. Populating a Database ......................................................................... 521 14.5. Non-Durable Settings .......................................................................... 524 15. Parallel Query .............................................................................................. 525 15.1. How Parallel Query Works .................................................................. 525
v


PostgreSQL 16.2 Documentation
15.2. When Can Parallel Query Be Used? ...................................................... 526 15.3. Parallel Plans ..................................................................................... 527 15.4. Parallel Safety ................................................................................... 529 III. Server Administration ............................................................................................ 531 16. Installation from Binaries ............................................................................... 538 17. Installation from Source Code ......................................................................... 539 17.1. Requirements ..................................................................................... 539 17.2. Getting the Source .............................................................................. 541 17.3. Building and Installation with Autoconf and Make ................................... 541 17.4. Building and Installation with Meson ..................................................... 554 17.5. Post-Installation Setup ......................................................................... 563 17.6. Supported Platforms ........................................................................... 565 17.7. Platform-Specific Notes ....................................................................... 565 18. Installation from Source Code on Windows ....................................................... 570 18.1. Building with Visual C++ or the Microsoft Windows SDK ........................ 570 19. Server Setup and Operation ............................................................................ 576 19.1. The PostgreSQL User Account ............................................................. 576 19.2. Creating a Database Cluster ................................................................. 576 19.3. Starting the Database Server ................................................................ 578 19.4. Managing Kernel Resources ................................................................. 582 19.5. Shutting Down the Server .................................................................... 590 19.6. Upgrading a PostgreSQL Cluster .......................................................... 590 19.7. Preventing Server Spoofing .................................................................. 593 19.8. Encryption Options ............................................................................. 594 19.9. Secure TCP/IP Connections with SSL .................................................... 595 19.10. Secure TCP/IP Connections with GSSAPI Encryption ............................. 599 19.11. Secure TCP/IP Connections with SSH Tunnels ...................................... 599 19.12. Registering Event Log on Windows ..................................................... 600 20. Server Configuration ..................................................................................... 602 20.1. Setting Parameters .............................................................................. 602 20.2. File Locations .................................................................................... 606 20.3. Connections and Authentication ............................................................ 607 20.4. Resource Consumption ........................................................................ 614 20.5. Write Ahead Log ............................................................................... 622 20.6. Replication ........................................................................................ 632 20.7. Query Planning .................................................................................. 639 20.8. Error Reporting and Logging ............................................................... 646 20.9. Run-time Statistics ............................................................................. 659 20.10. Automatic Vacuuming ....................................................................... 661 20.11. Client Connection Defaults ................................................................. 663 20.12. Lock Management ............................................................................ 674 20.13. Version and Platform Compatibility ..................................................... 675 20.14. Error Handling ................................................................................. 676 20.15. Preset Options .................................................................................. 677 20.16. Customized Options .......................................................................... 679 20.17. Developer Options ............................................................................ 679 20.18. Short Options ................................................................................... 685 21. Client Authentication ..................................................................................... 686 21.1. The pg_hba.conf File ..................................................................... 686 21.2. User Name Maps ............................................................................... 695 21.3. Authentication Methods ....................................................................... 697 21.4. Trust Authentication ........................................................................... 697 21.5. Password Authentication ..................................................................... 698 21.6. GSSAPI Authentication ....................................................................... 699 21.7. SSPI Authentication ............................................................................ 700 21.8. Ident Authentication ........................................................................... 701 21.9. Peer Authentication ............................................................................ 702 21.10. LDAP Authentication ........................................................................ 702
vi


PostgreSQL 16.2 Documentation
21.11. RADIUS Authentication .................................................................... 705 21.12. Certificate Authentication ................................................................... 706 21.13. PAM Authentication ......................................................................... 706 21.14. BSD Authentication .......................................................................... 707 21.15. Authentication Problems .................................................................... 707 22. Database Roles ............................................................................................. 709 22.1. Database Roles .................................................................................. 709 22.2. Role Attributes .................................................................................. 710 22.3. Role Membership ............................................................................... 712 22.4. Dropping Roles .................................................................................. 713 22.5. Predefined Roles ................................................................................ 714 22.6. Function Security ............................................................................... 716 23. Managing Databases ..................................................................................... 717 23.1. Overview .......................................................................................... 717 23.2. Creating a Database ............................................................................ 717 23.3. Template Databases ............................................................................ 718 23.4. Database Configuration ....................................................................... 720 23.5. Destroying a Database ........................................................................ 720 23.6. Tablespaces ....................................................................................... 720 24. Localization ................................................................................................. 723 24.1. Locale Support .................................................................................. 723 24.2. Collation Support ............................................................................... 727 24.3. Character Set Support ......................................................................... 737 25. Routine Database Maintenance Tasks ............................................................... 747 25.1. Routine Vacuuming ............................................................................ 747 25.2. Routine Reindexing ............................................................................ 756 25.3. Log File Maintenance ......................................................................... 757 26. Backup and Restore ...................................................................................... 759 26.1. SQL Dump ....................................................................................... 759 26.2. File System Level Backup ................................................................... 762 26.3. Continuous Archiving and Point-in-Time Recovery (PITR) ........................ 763 27. High Availability, Load Balancing, and Replication ............................................ 774 27.1. Comparison of Different Solutions ........................................................ 774 27.2. Log-Shipping Standby Servers .............................................................. 777 27.3. Failover ............................................................................................ 786 27.4. Hot Standby ...................................................................................... 786 28. Monitoring Database Activity ......................................................................... 795 28.1. Standard Unix Tools ........................................................................... 795 28.2. The Cumulative Statistics System ......................................................... 796 28.3. Viewing Locks .................................................................................. 835 28.4. Progress Reporting ............................................................................. 835 28.5. Dynamic Tracing ............................................................................... 843 29. Monitoring Disk Usage .................................................................................. 853 29.1. Determining Disk Usage ..................................................................... 853 29.2. Disk Full Failure ................................................................................ 854 30. Reliability and the Write-Ahead Log ................................................................ 855 30.1. Reliability ......................................................................................... 855 30.2. Data Checksums ................................................................................ 857 30.3. Write-Ahead Logging (WAL) ............................................................... 857 30.4. Asynchronous Commit ........................................................................ 858 30.5. WAL Configuration ............................................................................ 859 30.6. WAL Internals ................................................................................... 862 31. Logical Replication ....................................................................................... 864 31.1. Publication ........................................................................................ 864 31.2. Subscription ...................................................................................... 865 31.3. Row Filters ....................................................................................... 871 31.4. Column Lists ..................................................................................... 879 31.5. Conflicts ........................................................................................... 882
vii


PostgreSQL 16.2 Documentation
31.6. Restrictions ....................................................................................... 882 31.7. Architecture ...................................................................................... 883 31.8. Monitoring ........................................................................................ 884 31.9. Security ............................................................................................ 884 31.10. Configuration Settings ....................................................................... 885 31.11. Quick Setup ..................................................................................... 886 32. Just-in-Time Compilation (JIT) ....................................................................... 887 32.1. What Is JIT compilation? .................................................................... 887 32.2. When to JIT? .................................................................................... 887 32.3. Configuration .................................................................................... 889 32.4. Extensibility ...................................................................................... 889 33. Regression Tests ........................................................................................... 890 33.1. Running the Tests .............................................................................. 890 33.2. Test Evaluation .................................................................................. 894 33.3. Variant Comparison Files .................................................................... 896 33.4. TAP Tests ......................................................................................... 897 33.5. Test Coverage Examination ................................................................. 898 IV. Client Interfaces ................................................................................................... 899 34. libpq — C Library ........................................................................................ 904 34.1. Database Connection Control Functions ................................................. 904 34.2. Connection Status Functions ................................................................ 922 34.3. Command Execution Functions ............................................................. 929 34.4. Asynchronous Command Processing ...................................................... 944 34.5. Pipeline Mode ................................................................................... 948 34.6. Retrieving Query Results Row-by-Row .................................................. 953 34.7. Canceling Queries in Progress .............................................................. 953 34.8. The Fast-Path Interface ....................................................................... 954 34.9. Asynchronous Notification ................................................................... 955 34.10. Functions Associated with the COPY Command ..................................... 956 34.11. Control Functions ............................................................................. 960 34.12. Miscellaneous Functions .................................................................... 962 34.13. Notice Processing ............................................................................. 966 34.14. Event System ................................................................................... 967 34.15. Environment Variables ...................................................................... 973 34.16. The Password File ............................................................................ 975 34.17. The Connection Service File ............................................................... 976 34.18. LDAP Lookup of Connection Parameters .............................................. 976 34.19. SSL Support .................................................................................... 977 34.20. Behavior in Threaded Programs .......................................................... 981 34.21. Building libpq Programs .................................................................... 982 34.22. Example Programs ............................................................................ 983 35. Large Objects .............................................................................................. 995 35.1. Introduction ....................................................................................... 995 35.2. Implementation Features ...................................................................... 995 35.3. Client Interfaces ................................................................................. 995 35.4. Server-Side Functions ....................................................................... 1000 35.5. Example Program ............................................................................. 1001 36. ECPG — Embedded SQL in C ..................................................................... 1007 36.1. The Concept .................................................................................... 1007 36.2. Managing Database Connections ......................................................... 1007 36.3. Running SQL Commands .................................................................. 1011 36.4. Using Host Variables ........................................................................ 1014 36.5. Dynamic SQL .................................................................................. 1028 36.6. pgtypes Library ................................................................................ 1030 36.7. Using Descriptor Areas ..................................................................... 1044 36.8. Error Handling ................................................................................. 1057 36.9. Preprocessor Directives ..................................................................... 1064 36.10. Processing Embedded SQL Programs ................................................. 1066
viii


PostgreSQL 16.2 Documentation
36.11. Library Functions ............................................................................ 1067 36.12. Large Objects ................................................................................. 1068 36.13. C++ Applications ............................................................................ 1069 36.14. Embedded SQL Commands .............................................................. 1073 36.15. Informix Compatibility Mode ............................................................ 1097 36.16. Oracle Compatibility Mode ............................................................... 1112 36.17. Internals ........................................................................................ 1112 37. The Information Schema .............................................................................. 1115 37.1. The Schema ..................................................................................... 1115 37.2. Data Types ...................................................................................... 1115 37.3. information_schema_catalog_name ........................................ 1116 37.4. administrable_role_authorizations .................................... 1116 37.5. applicable_roles ..................................................................... 1116 37.6. attributes ................................................................................. 1117 37.7. character_sets ......................................................................... 1119 37.8. check_constraint_routine_usage .......................................... 1120 37.9. check_constraints ................................................................... 1120 37.10. collations ................................................................................ 1121 37.11. collation_character_set_applicability .......................... 1121 37.12. column_column_usage .............................................................. 1122 37.13. column_domain_usage .............................................................. 1122 37.14. column_options ........................................................................ 1122 37.15. column_privileges .................................................................. 1123 37.16. column_udt_usage .................................................................... 1124 37.17. columns ...................................................................................... 1124 37.18. constraint_column_usage ...................................................... 1127 37.19. constraint_table_usage ........................................................ 1128 37.20. data_type_privileges ............................................................ 1128 37.21. domain_constraints ................................................................ 1129 37.22. domain_udt_usage .................................................................... 1129 37.23. domains ...................................................................................... 1130 37.24. element_types .......................................................................... 1132 37.25. enabled_roles .......................................................................... 1134 37.26. foreign_data_wrapper_options ............................................ 1134 37.27. foreign_data_wrappers .......................................................... 1135 37.28. foreign_server_options ........................................................ 1135 37.29. foreign_servers ...................................................................... 1135 37.30. foreign_table_options .......................................................... 1136 37.31. foreign_tables ........................................................................ 1136 37.32. key_column_usage .................................................................... 1137 37.33. parameters ................................................................................ 1137 37.34. referential_constraints ...................................................... 1139 37.35. role_column_grants ................................................................ 1140 37.36. role_routine_grants .............................................................. 1140 37.37. role_table_grants .................................................................. 1141 37.38. role_udt_grants ...................................................................... 1142 37.39. role_usage_grants .................................................................. 1142 37.40. routine_column_usage ............................................................ 1143 37.41. routine_privileges ................................................................ 1143 37.42. routine_routine_usage .......................................................... 1144 37.43. routine_sequence_usage ........................................................ 1145 37.44. routine_table_usage .............................................................. 1145 37.45. routines .................................................................................... 1146 37.46. schemata .................................................................................... 1150 37.47. sequences .................................................................................. 1150 37.48. sql_features ............................................................................ 1151 37.49. sql_implementation_info ...................................................... 1152 37.50. sql_parts .................................................................................. 1152
ix


PostgreSQL 16.2 Documentation
37.51. sql_sizing ................................................................................ 1153 37.52. table_constraints .................................................................. 1153 37.53. table_privileges .................................................................... 1154 37.54. tables ........................................................................................ 1154 37.55. transforms ................................................................................ 1155 37.56. triggered_update_columns .................................................... 1156 37.57. triggers .................................................................................... 1156 37.58. udt_privileges ........................................................................ 1158 37.59. usage_privileges .................................................................... 1158 37.60. user_defined_types ................................................................ 1159 37.61. user_mapping_options ............................................................ 1161 37.62. user_mappings .......................................................................... 1161 37.63. view_column_usage .................................................................. 1161 37.64. view_routine_usage ................................................................ 1162 37.65. view_table_usage .................................................................... 1162 37.66. views .......................................................................................... 1163 V. Server Programming ............................................................................................. 1165 38. Extending SQL ........................................................................................... 1171 38.1. How Extensibility Works ................................................................... 1171 38.2. The PostgreSQL Type System ............................................................ 1171 38.3. User-Defined Functions ..................................................................... 1174 38.4. User-Defined Procedures ................................................................... 1175 38.5. Query Language (SQL) Functions ....................................................... 1175 38.6. Function Overloading ........................................................................ 1192 38.7. Function Volatility Categories ............................................................. 1193 38.8. Procedural Language Functions ........................................................... 1194 38.9. Internal Functions ............................................................................. 1194 38.10. C-Language Functions ..................................................................... 1195 38.11. Function Optimization Information .................................................... 1215 38.12. User-Defined Aggregates ................................................................. 1217 38.13. User-Defined Types ........................................................................ 1224 38.14. User-Defined Operators ................................................................... 1228 38.15. Operator Optimization Information .................................................... 1229 38.16. Interfacing Extensions to Indexes ....................................................... 1233 38.17. Packaging Related Objects into an Extension ....................................... 1246 38.18. Extension Building Infrastructure ....................................................... 1254 39. Triggers ..................................................................................................... 1259 39.1. Overview of Trigger Behavior ............................................................ 1259 39.2. Visibility of Data Changes ................................................................. 1262 39.3. Writing Trigger Functions in C ........................................................... 1262 39.4. A Complete Trigger Example ............................................................. 1265 40. Event Triggers ............................................................................................ 1269 40.1. Overview of Event Trigger Behavior .................................................... 1269 40.2. Event Trigger Firing Matrix ............................................................... 1270 40.3. Writing Event Trigger Functions in C .................................................. 1273 40.4. A Complete Event Trigger Example .................................................... 1274 40.5. A Table Rewrite Event Trigger Example .............................................. 1275 41. The Rule System ........................................................................................ 1277 41.1. The Query Tree ................................................................................ 1277 41.2. Views and the Rule System ................................................................ 1279 41.3. Materialized Views ........................................................................... 1285 41.4. Rules on INSERT, UPDATE, and DELETE ........................................... 1288 41.5. Rules and Privileges .......................................................................... 1299 41.6. Rules and Command Status ................................................................ 1301 41.7. Rules Versus Triggers ....................................................................... 1301 42. Procedural Languages .................................................................................. 1304 42.1. Installing Procedural Languages .......................................................... 1304 43. PL/pgSQL — SQL Procedural Language ........................................................ 1307
x


PostgreSQL 16.2 Documentation
43.1. Overview ........................................................................................ 1307 43.2. Structure of PL/pgSQL ...................................................................... 1308 43.3. Declarations ..................................................................................... 1310 43.4. Expressions ..................................................................................... 1316 43.5. Basic Statements .............................................................................. 1317 43.6. Control Structures ............................................................................. 1325 43.7. Cursors ........................................................................................... 1340 43.8. Transaction Management ................................................................... 1346 43.9. Errors and Messages ......................................................................... 1347 43.10. Trigger Functions ............................................................................ 1349 43.11. PL/pgSQL under the Hood ............................................................... 1358 43.12. Tips for Developing in PL/pgSQL ..................................................... 1361 43.13. Porting from Oracle PL/SQL ............................................................ 1365 44. PL/Tcl — Tcl Procedural Language ............................................................... 1375 44.1. Overview ........................................................................................ 1375 44.2. PL/Tcl Functions and Arguments ........................................................ 1375 44.3. Data Values in PL/Tcl ....................................................................... 1377 44.4. Global Data in PL/Tcl ....................................................................... 1377 44.5. Database Access from PL/Tcl ............................................................. 1378 44.6. Trigger Functions in PL/Tcl ............................................................... 1380 44.7. Event Trigger Functions in PL/Tcl ....................................................... 1382 44.8. Error Handling in PL/Tcl ................................................................... 1382 44.9. Explicit Subtransactions in PL/Tcl ....................................................... 1383 44.10. Transaction Management .................................................................. 1384 44.11. PL/Tcl Configuration ....................................................................... 1385 44.12. Tcl Procedure Names ...................................................................... 1385 45. PL/Perl — Perl Procedural Language ............................................................. 1386 45.1. PL/Perl Functions and Arguments ....................................................... 1386 45.2. Data Values in PL/Perl ...................................................................... 1391 45.3. Built-in Functions ............................................................................. 1391 45.4. Global Values in PL/Perl ................................................................... 1396 45.5. Trusted and Untrusted PL/Perl ............................................................ 1397 45.6. PL/Perl Triggers ............................................................................... 1398 45.7. PL/Perl Event Triggers ...................................................................... 1399 45.8. PL/Perl Under the Hood .................................................................... 1400 46. PL/Python — Python Procedural Language ..................................................... 1402 46.1. PL/Python Functions ......................................................................... 1402 46.2. Data Values ..................................................................................... 1403 46.3. Sharing Data .................................................................................... 1409 46.4. Anonymous Code Blocks ................................................................... 1409 46.5. Trigger Functions ............................................................................. 1409 46.6. Database Access ............................................................................... 1410 46.7. Explicit Subtransactions ..................................................................... 1414 46.8. Transaction Management ................................................................... 1415 46.9. Utility Functions .............................................................................. 1415 46.10. Python 2 vs. Python 3 ..................................................................... 1416 46.11. Environment Variables ..................................................................... 1416 47. Server Programming Interface ....................................................................... 1418 47.1. Interface Functions ........................................................................... 1418 47.2. Interface Support Functions ................................................................ 1460 47.3. Memory Management ....................................................................... 1469 47.4. Transaction Management ................................................................... 1479 47.5. Visibility of Data Changes ................................................................. 1482 47.6. Examples ........................................................................................ 1482 48. Background Worker Processes ...................................................................... 1486 49. Logical Decoding ........................................................................................ 1489 49.1. Logical Decoding Examples ............................................................... 1489 49.2. Logical Decoding Concepts ................................................................ 1493
xi


PostgreSQL 16.2 Documentation
49.3. Streaming Replication Protocol Interface .............................................. 1494 49.4. Logical Decoding SQL Interface ......................................................... 1495 49.5. System Catalogs Related to Logical Decoding ....................................... 1495 49.6. Logical Decoding Output Plugins ........................................................ 1495 49.7. Logical Decoding Output Writers ........................................................ 1503 49.8. Synchronous Replication Support for Logical Decoding ........................... 1503 49.9. Streaming of Large Transactions for Logical Decoding ............................ 1504 49.10. Two-phase Commit Support for Logical Decoding ................................ 1505 50. Replication Progress Tracking ....................................................................... 1507 51. Archive Modules ........................................................................................ 1508 51.1. Initialization Functions ...................................................................... 1508 51.2. Archive Module Callbacks ................................................................. 1508 VI. Reference .......................................................................................................... 1510 I. SQL Commands ............................................................................................ 1515 ABORT .................................................................................................. 1519 ALTER AGGREGATE ............................................................................. 1520 ALTER COLLATION .............................................................................. 1522 ALTER CONVERSION ............................................................................ 1525 ALTER DATABASE ................................................................................ 1527 ALTER DEFAULT PRIVILEGES .............................................................. 1530 ALTER DOMAIN .................................................................................... 1533 ALTER EVENT TRIGGER ....................................................................... 1537 ALTER EXTENSION ............................................................................... 1538 ALTER FOREIGN DATA WRAPPER ........................................................ 1542 ALTER FOREIGN TABLE ....................................................................... 1544 ALTER FUNCTION ................................................................................. 1549 ALTER GROUP ...................................................................................... 1553 ALTER INDEX ....................................................................................... 1555 ALTER LANGUAGE ............................................................................... 1558 ALTER LARGE OBJECT ......................................................................... 1559 ALTER MATERIALIZED VIEW ............................................................... 1560 ALTER OPERATOR ................................................................................ 1562 ALTER OPERATOR CLASS .................................................................... 1564 ALTER OPERATOR FAMILY .................................................................. 1565 ALTER POLICY ..................................................................................... 1569 ALTER PROCEDURE .............................................................................. 1571 ALTER PUBLICATION ........................................................................... 1574 ALTER ROLE ......................................................................................... 1577 ALTER ROUTINE ................................................................................... 1581 ALTER RULE ......................................................................................... 1583 ALTER SCHEMA ................................................................................... 1584 ALTER SEQUENCE ................................................................................ 1585 ALTER SERVER ..................................................................................... 1588 ALTER STATISTICS ............................................................................... 1590 ALTER SUBSCRIPTION .......................................................................... 1591 ALTER SYSTEM .................................................................................... 1594 ALTER TABLE ....................................................................................... 1596 ALTER TABLESPACE ............................................................................ 1614 ALTER TEXT SEARCH CONFIGURATION .............................................. 1616 ALTER TEXT SEARCH DICTIONARY ..................................................... 1618 ALTER TEXT SEARCH PARSER ............................................................. 1620 ALTER TEXT SEARCH TEMPLATE ........................................................ 1621 ALTER TRIGGER ................................................................................... 1622 ALTER TYPE ......................................................................................... 1624 ALTER USER ......................................................................................... 1629 ALTER USER MAPPING ......................................................................... 1630 ALTER VIEW ......................................................................................... 1631 ANALYZE .............................................................................................. 1633
xii


PostgreSQL 16.2 Documentation
BEGIN ................................................................................................... 1636 CALL ..................................................................................................... 1638 CHECKPOINT ........................................................................................ 1640 CLOSE ................................................................................................... 1641 CLUSTER .............................................................................................. 1642 COMMENT ............................................................................................ 1645 COMMIT ................................................................................................ 1650 COMMIT PREPARED ............................................................................. 1651 COPY .................................................................................................... 1652 CREATE ACCESS METHOD ................................................................... 1662 CREATE AGGREGATE ........................................................................... 1663 CREATE CAST ....................................................................................... 1671 CREATE COLLATION ............................................................................ 1675 CREATE CONVERSION .......................................................................... 1678 CREATE DATABASE ............................................................................. 1680 CREATE DOMAIN ................................................................................. 1685 CREATE EVENT TRIGGER ..................................................................... 1688 CREATE EXTENSION ............................................................................ 1690 CREATE FOREIGN DATA WRAPPER ...................................................... 1693 CREATE FOREIGN TABLE ..................................................................... 1695 CREATE FUNCTION .............................................................................. 1700 CREATE GROUP .................................................................................... 1709 CREATE INDEX ..................................................................................... 1710 CREATE LANGUAGE ............................................................................. 1719 CREATE MATERIALIZED VIEW ............................................................. 1722 CREATE OPERATOR .............................................................................. 1724 CREATE OPERATOR CLASS .................................................................. 1727 CREATE OPERATOR FAMILY ................................................................ 1730 CREATE POLICY ................................................................................... 1731 CREATE PROCEDURE ........................................................................... 1737 CREATE PUBLICATION ......................................................................... 1741 CREATE ROLE ...................................................................................... 1745 CREATE RULE ...................................................................................... 1750 CREATE SCHEMA ................................................................................. 1753 CREATE SEQUENCE .............................................................................. 1756 CREATE SERVER .................................................................................. 1760 CREATE STATISTICS ............................................................................. 1762 CREATE SUBSCRIPTION ....................................................................... 1766 CREATE TABLE .................................................................................... 1771 CREATE TABLE AS ............................................................................... 1794 CREATE TABLESPACE .......................................................................... 1797 CREATE TEXT SEARCH CONFIGURATION ............................................ 1799 CREATE TEXT SEARCH DICTIONARY ................................................... 1800 CREATE TEXT SEARCH PARSER ........................................................... 1802 CREATE TEXT SEARCH TEMPLATE ...................................................... 1804 CREATE TRANSFORM ........................................................................... 1805 CREATE TRIGGER ................................................................................. 1807 CREATE TYPE ....................................................................................... 1814 CREATE USER ....................................................................................... 1823 CREATE USER MAPPING ....................................................................... 1824 CREATE VIEW ...................................................................................... 1826 DEALLOCATE ....................................................................................... 1832 DECLARE .............................................................................................. 1833 DELETE ................................................................................................. 1837 DISCARD ............................................................................................... 1840 DO ........................................................................................................ 1841 DROP ACCESS METHOD ....................................................................... 1843 DROP AGGREGATE ............................................................................... 1844
xiii


PostgreSQL 16.2 Documentation
DROP CAST ........................................................................................... 1846 DROP COLLATION ................................................................................ 1847 DROP CONVERSION .............................................................................. 1848 DROP DATABASE ................................................................................. 1849 DROP DOMAIN ...................................................................................... 1850 DROP EVENT TRIGGER ......................................................................... 1851 DROP EXTENSION ................................................................................. 1852 DROP FOREIGN DATA WRAPPER .......................................................... 1853 DROP FOREIGN TABLE ......................................................................... 1854 DROP FUNCTION .................................................................................. 1855 DROP GROUP ........................................................................................ 1857 DROP INDEX ......................................................................................... 1858 DROP LANGUAGE ................................................................................. 1860 DROP MATERIALIZED VIEW ................................................................. 1861 DROP OPERATOR .................................................................................. 1862 DROP OPERATOR CLASS ...................................................................... 1864 DROP OPERATOR FAMILY .................................................................... 1866 DROP OWNED ....................................................................................... 1868 DROP POLICY ....................................................................................... 1869 DROP PROCEDURE ............................................................................... 1870 DROP PUBLICATION ............................................................................. 1872 DROP ROLE .......................................................................................... 1873 DROP ROUTINE ..................................................................................... 1874 DROP RULE .......................................................................................... 1876 DROP SCHEMA ..................................................................................... 1877 DROP SEQUENCE .................................................................................. 1878 DROP SERVER ...................................................................................... 1879 DROP STATISTICS ................................................................................. 1880 DROP SUBSCRIPTION ............................................................................ 1881 DROP TABLE ........................................................................................ 1883 DROP TABLESPACE .............................................................................. 1884 DROP TEXT SEARCH CONFIGURATION ................................................ 1885 DROP TEXT SEARCH DICTIONARY ....................................................... 1886 DROP TEXT SEARCH PARSER ............................................................... 1887 DROP TEXT SEARCH TEMPLATE .......................................................... 1888 DROP TRANSFORM ............................................................................... 1889 DROP TRIGGER ..................................................................................... 1890 DROP TYPE ........................................................................................... 1891 DROP USER ........................................................................................... 1892 DROP USER MAPPING ........................................................................... 1893 DROP VIEW .......................................................................................... 1894 END ...................................................................................................... 1895 EXECUTE .............................................................................................. 1896 EXPLAIN ............................................................................................... 1897 FETCH ................................................................................................... 1903 GRANT .................................................................................................. 1907 IMPORT FOREIGN SCHEMA .................................................................. 1913 INSERT .................................................................................................. 1915 LISTEN .................................................................................................. 1923 LOAD .................................................................................................... 1925 LOCK .................................................................................................... 1926 MERGE .................................................................................................. 1929 MOVE ................................................................................................... 1935 NOTIFY ................................................................................................. 1937 PREPARE ............................................................................................... 1940 PREPARE TRANSACTION ...................................................................... 1943 REASSIGN OWNED ............................................................................... 1945 REFRESH MATERIALIZED VIEW ........................................................... 1946
xiv


PostgreSQL 16.2 Documentation
REINDEX ............................................................................................... 1948 RELEASE SAVEPOINT ........................................................................... 1953 RESET ................................................................................................... 1955 REVOKE ................................................................................................ 1956 ROLLBACK ........................................................................................... 1961 ROLLBACK PREPARED ......................................................................... 1962 ROLLBACK TO SAVEPOINT .................................................................. 1963 SAVEPOINT ........................................................................................... 1965 SECURITY LABEL ................................................................................. 1967 SELECT ................................................................................................. 1970 SELECT INTO ........................................................................................ 1992 SET ....................................................................................................... 1994 SET CONSTRAINTS ............................................................................... 1997 SET ROLE ............................................................................................. 1998 SET SESSION AUTHORIZATION ............................................................ 2000 SET TRANSACTION ............................................................................... 2002 SHOW ................................................................................................... 2005 START TRANSACTION .......................................................................... 2007 TRUNCATE ........................................................................................... 2008 UNLISTEN ............................................................................................. 2010 UPDATE ................................................................................................ 2012 VACUUM .............................................................................................. 2017 VALUES ................................................................................................ 2022 II. PostgreSQL Client Applications ..................................................................... 2025 clusterdb ................................................................................................. 2026 createdb .................................................................................................. 2029 createuser ................................................................................................ 2033 dropdb .................................................................................................... 2038 dropuser .................................................................................................. 2041 ecpg ....................................................................................................... 2044 pg_amcheck ............................................................................................ 2047 pg_basebackup ......................................................................................... 2053 pgbench .................................................................................................. 2062 pg_config ................................................................................................ 2086 pg_dump ................................................................................................. 2089 pg_dumpall ............................................................................................. 2103 pg_isready ............................................................................................... 2110 pg_receivewal .......................................................................................... 2112 pg_recvlogical ......................................................................................... 2117 pg_restore ............................................................................................... 2121 pg_verifybackup ....................................................................................... 2130 psql ........................................................................................................ 2133 reindexdb ................................................................................................ 2177 vacuumdb ............................................................................................... 2181 III. PostgreSQL Server Applications .................................................................... 2186 initdb ..................................................................................................... 2187 pg_archivecleanup .................................................................................... 2192 pg_checksums .......................................................................................... 2194 pg_controldata ......................................................................................... 2196 pg_ctl ..................................................................................................... 2197 pg_resetwal ............................................................................................. 2203 pg_rewind ............................................................................................... 2207 pg_test_fsync ........................................................................................... 2211 pg_test_timing ......................................................................................... 2212 pg_upgrade .............................................................................................. 2216 pg_waldump ............................................................................................ 2225 postgres .................................................................................................. 2229 VII. Internals ........................................................................................................... 2236
xv


PostgreSQL 16.2 Documentation
52. Overview of PostgreSQL Internals ................................................................. 2242 52.1. The Path of a Query ......................................................................... 2242 52.2. How Connections Are Established ....................................................... 2242 52.3. The Parser Stage .............................................................................. 2243 52.4. The PostgreSQL Rule System ............................................................. 2244 52.5. Planner/Optimizer ............................................................................. 2244 52.6. Executor ......................................................................................... 2245 53. System Catalogs ......................................................................................... 2247 53.1. Overview ........................................................................................ 2247 53.2. pg_aggregate ............................................................................. 2249 53.3. pg_am ........................................................................................... 2250 53.4. pg_amop ....................................................................................... 2251 53.5. pg_amproc ................................................................................... 2252 53.6. pg_attrdef ................................................................................. 2252 53.7. pg_attribute ............................................................................. 2253 53.8. pg_authid ................................................................................... 2255 53.9. pg_auth_members ....................................................................... 2256 53.10. pg_cast ...................................................................................... 2256 53.11. pg_class .................................................................................... 2257 53.12. pg_collation ............................................................................ 2260 53.13. pg_constraint .......................................................................... 2260 53.14. pg_conversion .......................................................................... 2262 53.15. pg_database .............................................................................. 2263 53.16. pg_db_role_setting ................................................................ 2264 53.17. pg_default_acl ........................................................................ 2264 53.18. pg_depend .................................................................................. 2265 53.19. pg_description ........................................................................ 2267 53.20. pg_enum ...................................................................................... 2267 53.21. pg_event_trigger .................................................................... 2268 53.22. pg_extension ............................................................................ 2268 53.23. pg_foreign_data_wrapper ...................................................... 2269 53.24. pg_foreign_server .................................................................. 2270 53.25. pg_foreign_table .................................................................... 2270 53.26. pg_index .................................................................................... 2270 53.27. pg_inherits .............................................................................. 2272 53.28. pg_init_privs .......................................................................... 2272 53.29. pg_language .............................................................................. 2273 53.30. pg_largeobject ........................................................................ 2274 53.31. pg_largeobject_metadata ...................................................... 2274 53.32. pg_namespace ............................................................................ 2275 53.33. pg_opclass ................................................................................ 2275 53.34. pg_operator .............................................................................. 2276 53.35. pg_opfamily .............................................................................. 2276 53.36. pg_parameter_acl .................................................................... 2277 53.37. pg_partitioned_table ............................................................ 2277 53.38. pg_policy .................................................................................. 2278 53.39. pg_proc ...................................................................................... 2279 53.40. pg_publication ........................................................................ 2281 53.41. pg_publication_namespace .................................................... 2282 53.42. pg_publication_rel ................................................................ 2282 53.43. pg_range .................................................................................... 2282 53.44. pg_replication_origin .......................................................... 2283 53.45. pg_rewrite ................................................................................ 2283 53.46. pg_seclabel .............................................................................. 2284 53.47. pg_sequence .............................................................................. 2285 53.48. pg_shdepend .............................................................................. 2285 53.49. pg_shdescription .................................................................... 2286 53.50. pg_shseclabel .......................................................................... 2287
xvi


PostgreSQL 16.2 Documentation
53.51. pg_statistic ............................................................................ 2287 53.52. pg_statistic_ext .................................................................... 2288 53.53. pg_statistic_ext_data .......................................................... 2289 53.54. pg_subscription ...................................................................... 2290 53.55. pg_subscription_rel .............................................................. 2291 53.56. pg_tablespace .......................................................................... 2291 53.57. pg_transform ............................................................................ 2292 53.58. pg_trigger ................................................................................ 2292 53.59. pg_ts_config ............................................................................ 2294 53.60. pg_ts_config_map .................................................................... 2294 53.61. pg_ts_dict ................................................................................ 2295 53.62. pg_ts_parser ............................................................................ 2295 53.63. pg_ts_template ........................................................................ 2296 53.64. pg_type ...................................................................................... 2296 53.65. pg_user_mapping ...................................................................... 2300 54. System Views ............................................................................................ 2301 54.1. Overview ........................................................................................ 2301 54.2. pg_available_extensions ........................................................ 2302 54.3. pg_available_extension_versions ........................................ 2302 54.4. pg_backend_memory_contexts .................................................. 2303 54.5. pg_config ................................................................................... 2304 54.6. pg_cursors ................................................................................. 2304 54.7. pg_file_settings ..................................................................... 2305 54.8. pg_group ..................................................................................... 2305 54.9. pg_hba_file_rules ................................................................... 2306 54.10. pg_ident_file_mappings ........................................................ 2307 54.11. pg_indexes ................................................................................ 2307 54.12. pg_locks .................................................................................... 2308 54.13. pg_matviews .............................................................................. 2310 54.14. pg_policies .............................................................................. 2311 54.15. pg_prepared_statements ........................................................ 2311 54.16. pg_prepared_xacts .................................................................. 2312 54.17. pg_publication_tables .......................................................... 2313 54.18. pg_replication_origin_status ............................................ 2313 54.19. pg_replication_slots ............................................................ 2314 54.20. pg_roles .................................................................................... 2315 54.21. pg_rules .................................................................................... 2316 54.22. pg_seclabels ............................................................................ 2316 54.23. pg_sequences ............................................................................ 2317 54.24. pg_settings .............................................................................. 2317 54.25. pg_shadow .................................................................................. 2320 54.26. pg_shmem_allocations ............................................................ 2320 54.27. pg_stats .................................................................................... 2321 54.28. pg_stats_ext ............................................................................ 2322 54.29. pg_stats_ext_exprs ................................................................ 2323 54.30. pg_tables .................................................................................. 2325 54.31. pg_timezone_abbrevs .............................................................. 2325 54.32. pg_timezone_names .................................................................. 2326 54.33. pg_user ...................................................................................... 2326 54.34. pg_user_mappings .................................................................... 2327 54.35. pg_views .................................................................................... 2327 55. Frontend/Backend Protocol ........................................................................... 2329 55.1. Overview ........................................................................................ 2329 55.2. Message Flow .................................................................................. 2330 55.3. SASL Authentication ........................................................................ 2344 55.4. Streaming Replication Protocol ........................................................... 2345 55.5. Logical Streaming Replication Protocol ................................................ 2354 55.6. Message Data Types ......................................................................... 2356
xvii


PostgreSQL 16.2 Documentation
55.7. Message Formats .............................................................................. 2356 55.8. Error and Notice Message Fields ......................................................... 2373 55.9. Logical Replication Message Formats .................................................. 2375 55.10. Summary of Changes since Protocol 2.0 ............................................. 2384 56. PostgreSQL Coding Conventions ................................................................... 2386 56.1. Formatting ....................................................................................... 2386 56.2. Reporting Errors Within the Server ...................................................... 2386 56.3. Error Message Style Guide ................................................................. 2390 56.4. Miscellaneous Coding Conventions ...................................................... 2394 57. Native Language Support ............................................................................. 2396 57.1. For the Translator ............................................................................. 2396 57.2. For the Programmer .......................................................................... 2398 58. Writing a Procedural Language Handler .......................................................... 2402 59. Writing a Foreign Data Wrapper .................................................................... 2404 59.1. Foreign Data Wrapper Functions ......................................................... 2404 59.2. Foreign Data Wrapper Callback Routines .............................................. 2404 59.3. Foreign Data Wrapper Helper Functions ............................................... 2420 59.4. Foreign Data Wrapper Query Planning ................................................. 2421 59.5. Row Locking in Foreign Data Wrappers ............................................... 2424 60. Writing a Table Sampling Method ................................................................. 2426 60.1. Sampling Method Support Functions .................................................... 2426 61. Writing a Custom Scan Provider .................................................................... 2429 61.1. Creating Custom Scan Paths ............................................................... 2429 61.2. Creating Custom Scan Plans ............................................................... 2430 61.3. Executing Custom Scans .................................................................... 2431 62. Genetic Query Optimizer .............................................................................. 2434 62.1. Query Handling as a Complex Optimization Problem .............................. 2434 62.2. Genetic Algorithms ........................................................................... 2434 62.3. Genetic Query Optimization (GEQO) in PostgreSQL .............................. 2435 62.4. Further Reading ............................................................................... 2437 63. Table Access Method Interface Definition ....................................................... 2438 64. Index Access Method Interface Definition ....................................................... 2439 64.1. Basic API Structure for Indexes .......................................................... 2439 64.2. Index Access Method Functions .......................................................... 2442 64.3. Index Scanning ................................................................................ 2448 64.4. Index Locking Considerations ............................................................. 2449 64.5. Index Uniqueness Checks .................................................................. 2450 64.6. Index Cost Estimation Functions ......................................................... 2451 65. Generic WAL Records ................................................................................. 2455 66. Custom WAL Resource Managers ................................................................. 2457 67. B-Tree Indexes ........................................................................................... 2459 67.1. Introduction ..................................................................................... 2459 67.2. Behavior of B-Tree Operator Classes ................................................... 2459 67.3. B-Tree Support Functions .................................................................. 2460 67.4. Implementation ................................................................................ 2463 68. GiST Indexes ............................................................................................. 2466 68.1. Introduction ..................................................................................... 2466 68.2. Built-in Operator Classes ................................................................... 2466 68.3. Extensibility .................................................................................... 2469 68.4. Implementation ................................................................................ 2482 68.5. Examples ........................................................................................ 2482 69. SP-GiST Indexes ........................................................................................ 2484 69.1. Introduction ..................................................................................... 2484 69.2. Built-in Operator Classes ................................................................... 2484 69.3. Extensibility .................................................................................... 2486 69.4. Implementation ................................................................................ 2495 69.5. Examples ........................................................................................ 2496 70. GIN Indexes .............................................................................................. 2497
xviii


PostgreSQL 16.2 Documentation
70.1. Introduction ..................................................................................... 2497 70.2. Built-in Operator Classes ................................................................... 2497 70.3. Extensibility .................................................................................... 2498 70.4. Implementation ................................................................................ 2500 70.5. GIN Tips and Tricks ......................................................................... 2502 70.6. Limitations ...................................................................................... 2502 70.7. Examples ........................................................................................ 2503 71. BRIN Indexes ............................................................................................ 2504 71.1. Introduction ..................................................................................... 2504 71.2. Built-in Operator Classes ................................................................... 2505 71.3. Extensibility .................................................................................... 2512 72. Hash Indexes .............................................................................................. 2517 72.1. Overview ........................................................................................ 2517 72.2. Implementation ................................................................................ 2518 73. Database Physical Storage ............................................................................ 2519 73.1. Database File Layout ........................................................................ 2519 73.2. TOAST ........................................................................................... 2521 73.3. Free Space Map ............................................................................... 2524 73.4. Visibility Map .................................................................................. 2524 73.5. The Initialization Fork ....................................................................... 2525 73.6. Database Page Layout ....................................................................... 2525 73.7. Heap-Only Tuples (HOT) .................................................................. 2528 74. Transaction Processing ................................................................................. 2529 74.1. Transactions and Identifiers ................................................................ 2529 74.2. Transactions and Locking .................................................................. 2529 74.3. Subtransactions ................................................................................ 2529 74.4. Two-Phase Transactions .................................................................... 2530 75. System Catalog Declarations and Initial Contents ............................................. 2531 75.1. System Catalog Declaration Rules ....................................................... 2531 75.2. System Catalog Initial Data ................................................................ 2532 75.3. BKI File Format ............................................................................... 2537 75.4. BKI Commands ............................................................................... 2537 75.5. Structure of the Bootstrap BKI File ..................................................... 2538 75.6. BKI Example ................................................................................... 2539 76. How the Planner Uses Statistics .................................................................... 2540 76.1. Row Estimation Examples ................................................................. 2540 76.2. Multivariate Statistics Examples .......................................................... 2545 76.3. Planner Statistics and Security ............................................................ 2549 77. Backup Manifest Format .............................................................................. 2550 77.1. Backup Manifest Top-level Object ....................................................... 2550 77.2. Backup Manifest File Object .............................................................. 2550 77.3. Backup Manifest WAL Range Object .................................................. 2551 VIII. Appendixes ...................................................................................................... 2552 A. PostgreSQL Error Codes ............................................................................... 2559 B. Date/Time Support ....................................................................................... 2568 B.1. Date/Time Input Interpretation ............................................................. 2568 B.2. Handling of Invalid or Ambiguous Timestamps ....................................... 2569 B.3. Date/Time Key Words ........................................................................ 2570 B.4. Date/Time Configuration Files ............................................................. 2571 B.5. POSIX Time Zone Specifications ......................................................... 2572 B.6. History of Units ................................................................................ 2574 B.7. Julian Dates ...................................................................................... 2575 C. SQL Key Words .......................................................................................... 2576 D. SQL Conformance ....................................................................................... 2601 D.1. Supported Features ............................................................................ 2602 D.2. Unsupported Features ......................................................................... 2613 D.3. XML Limits and Conformance to SQL/XML ......................................... 2622 E. Release Notes .............................................................................................. 2626
xix


PostgreSQL 16.2 Documentation
E.1. Release 16.2 ..................................................................................... 2626 E.2. Release 16.1 ..................................................................................... 2632 E.3. Release 16 ........................................................................................ 2637 E.4. Prior Releases ................................................................................... 2658 F. Additional Supplied Modules and Extensions .................................................... 2659 F.1. adminpack — pgAdmin support toolpack ............................................... 2661 F.2. amcheck — tools to verify table and index consistency ............................. 2663 F.3. auth_delay — pause on authentication failure .......................................... 2669 F.4. auto_explain — log execution plans of slow queries ................................. 2670 F.5. basebackup_to_shell — example "shell" pg_basebackup module ................. 2673 F.6. basic_archive — an example WAL archive module .................................. 2674 F.7. bloom — bloom filter index access method ............................................ 2675 F.8. btree_gin — GIN operator classes with B-tree behavior ............................ 2679 F.9. btree_gist — GiST operator classes with B-tree behavior ........................... 2680 F.10. citext — a case-insensitive character string type ..................................... 2682 F.11. cube — a multi-dimensional cube data type .......................................... 2685 F.12. dblink — connect to other PostgreSQL databases ................................... 2690 F.13. dict_int — example full-text search dictionary for integers ....................... 2722 F.14. dict_xsyn — example synonym full-text search dictionary ....................... 2723 F.15. earthdistance — calculate great-circle distances ..................................... 2725 F.16. file_fdw — access data files in the server's file system ............................ 2727 F.17. fuzzystrmatch — determine string similarities and distance ...................... 2730 F.18. hstore — hstore key/value datatype ..................................................... 2735 F.19. intagg — integer aggregator and enumerator ......................................... 2743 F.20. intarray — manipulate arrays of integers .............................................. 2745 F.21. isn — data types for international standard numbers (ISBN, EAN, UPC, etc.) ....................................................................................................... 2749 F.22. lo — manage large objects ................................................................. 2753 F.23. ltree — hierarchical tree-like data type ................................................. 2755 F.24. old_snapshot — inspect old_snapshot_threshold state ................. 2763 F.25. pageinspect — low-level inspection of database pages ............................. 2764 F.26. passwordcheck — verify password strength .......................................... 2775 F.27. pg_buffercache — inspect PostgreSQL buffer cache state ........................ 2776 F.28. pgcrypto — cryptographic functions .................................................... 2780 F.29. pg_freespacemap — examine the free space map ................................... 2791 F.30. pg_prewarm — preload relation data into buffer caches ........................... 2793 F.31. pgrowlocks — show a table's row locking information ............................ 2795 F.32. pg_stat_statements — track statistics of SQL planning and execution ......... 2797 F.33. pgstattuple — obtain tuple-level statistics ............................................. 2805 F.34. pg_surgery — perform low-level surgery on relation data ........................ 2810 F.35. pg_trgm — support for similarity of text using trigram matching ............... 2812 F.36. pg_visibility — visibility map information and utilities ............................ 2818 F.37. pg_walinspect — low-level WAL inspection ......................................... 2820 F.38. postgres_fdw — access data stored in external PostgreSQL servers ............ 2824 F.39. seg — a datatype for line segments or floating point intervals ................... 2834 F.40. sepgsql — SELinux-, label-based mandatory access control (MAC) security module ................................................................................................... 2837 F.41. spi — Server Programming Interface features/examples ........................... 2845 F.42. sslinfo — obtain client SSL information ............................................... 2847 F.43. tablefunc — functions that return tables (crosstab and others) .............. 2849 F.44. tcn — a trigger function to notify listeners of changes to table content ........ 2859 F.45. test_decoding — SQL-based test/example module for WAL logical decoding ......................................................................................................... 2861 F.46. tsm_system_rows — the SYSTEM_ROWS sampling method for TABLESAMPLE ....................................................................................... 2862 F.47. tsm_system_time — the SYSTEM_TIME sampling method for TABLESAMPLE ....................................................................................................... 2863 F.48. unaccent — a text search dictionary which removes diacritics ................... 2864
xx


PostgreSQL 16.2 Documentation
F.49. uuid-ossp — a UUID generator .......................................................... 2867 F.50. xml2 — XPath querying and XSLT functionality ................................... 2869 G. Additional Supplied Programs ........................................................................ 2874 G.1. Client Applications ............................................................................ 2874 G.2. Server Applications ............................................................................ 2881 H. External Projects .......................................................................................... 2882 H.1. Client Interfaces ................................................................................ 2882 H.2. Administration Tools .......................................................................... 2882 H.3. Procedural Languages ........................................................................ 2882 H.4. Extensions ........................................................................................ 2882 I. The Source Code Repository ........................................................................... 2883 I.1. Getting the Source via Git .................................................................... 2883 J. Documentation ............................................................................................. 2884 J.1. DocBook ........................................................................................... 2884 J.2. Tool Sets .......................................................................................... 2884 J.3. Building the Documentation with Make .................................................. 2886 J.4. Building the Documentation with Meson ................................................ 2888 J.5. Documentation Authoring .................................................................... 2888 J.6. Style Guide ....................................................................................... 2889 K. PostgreSQL Limits ....................................................................................... 2891 L. Acronyms ................................................................................................... 2892 M. Glossary .................................................................................................... 2899 N. Color Support .............................................................................................. 2913 N.1. When Color is Used .......................................................................... 2913 N.2. Configuring the Colors ....................................................................... 2913 O. Obsolete or Renamed Features ....................................................................... 2914 O.1. recovery.conf file merged into postgresql.conf ....................... 2914 O.2. Default Roles Renamed to Predefined Roles ........................................... 2914 O.3. pg_xlogdump renamed to pg_waldump ........................................... 2914 O.4. pg_resetxlog renamed to pg_resetwal ........................................ 2914 O.5. pg_receivexlog renamed to pg_receivewal ................................ 2914 Bibliography ............................................................................................................ 2916 Index ...................................................................................................................... 2918
xxi


List of Figures
62.1. Structure of a Genetic Algorithm ........................................................................ 2435 70.1. GIN Internals ................................................................................................... 2501 73.1. Page Layout .................................................................................................... 2527
xxii


List of Tables
4.1. Backslash Escape Sequences ................................................................................... 36 4.2. Operator Precedence (highest to lowest) .................................................................... 41 5.1. ACL Privilege Abbreviations ................................................................................... 78 5.2. Summary of Access Privileges ................................................................................. 78 8.1. Data Types ......................................................................................................... 146 8.2. Numeric Types .................................................................................................... 147 8.3. Monetary Types .................................................................................................. 153 8.4. Character Types .................................................................................................. 154 8.5. Special Character Types ........................................................................................ 155 8.6. Binary Data Types ............................................................................................... 156 8.7. bytea Literal Escaped Octets ............................................................................... 157 8.8. bytea Output Escaped Octets ............................................................................... 157 8.9. Date/Time Types ................................................................................................. 158 8.10. Date Input ......................................................................................................... 159 8.11. Time Input ........................................................................................................ 160 8.12. Time Zone Input ................................................................................................ 161 8.13. Special Date/Time Inputs ..................................................................................... 162 8.14. Date/Time Output Styles ..................................................................................... 163 8.15. Date Order Conventions ...................................................................................... 163 8.16. ISO 8601 Interval Unit Abbreviations .................................................................... 165 8.17. Interval Input ..................................................................................................... 166 8.18. Interval Output Style Examples ............................................................................ 167 8.19. Boolean Data Type ............................................................................................. 167 8.20. Geometric Types ................................................................................................ 170 8.21. Network Address Types ...................................................................................... 173 8.22. cidr Type Input Examples ................................................................................. 173 8.23. JSON Primitive Types and Corresponding PostgreSQL Types .................................... 182 8.24. jsonpath Variables ......................................................................................... 191 8.25. jsonpath Accessors ........................................................................................ 191 8.26. Object Identifier Types ....................................................................................... 214 8.27. Pseudo-Types .................................................................................................... 217 9.1. Comparison Operators .......................................................................................... 220 9.2. Comparison Predicates .......................................................................................... 220 9.3. Comparison Functions .......................................................................................... 223 9.4. Mathematical Operators ........................................................................................ 224 9.5. Mathematical Functions ........................................................................................ 226 9.6. Random Functions ............................................................................................... 229 9.7. Trigonometric Functions ....................................................................................... 229 9.8. Hyperbolic Functions ........................................................................................... 231 9.9. SQL String Functions and Operators ....................................................................... 232 9.10. Other String Functions and Operators .................................................................... 234 9.11. SQL Binary String Functions and Operators ........................................................... 242 9.12. Other Binary String Functions .............................................................................. 243 9.13. Text/Binary String Conversion Functions ............................................................... 244 9.14. Bit String Operators ........................................................................................... 246 9.15. Bit String Functions ........................................................................................... 246 9.16. Regular Expression Match Operators ..................................................................... 251 9.17. Regular Expression Atoms ................................................................................... 256 9.18. Regular Expression Quantifiers ............................................................................. 257 9.19. Regular Expression Constraints ............................................................................ 258 9.20. Regular Expression Character-Entry Escapes ........................................................... 259 9.21. Regular Expression Class-Shorthand Escapes .......................................................... 260 9.22. Regular Expression Constraint Escapes .................................................................. 261 9.23. Regular Expression Back References ..................................................................... 261 9.24. ARE Embedded-Option Letters ............................................................................ 262
xxiii


PostgreSQL 16.2 Documentation
9.25. Regular Expression Functions Equivalencies ........................................................... 265 9.26. Formatting Functions .......................................................................................... 266 9.27. Template Patterns for Date/Time Formatting ........................................................... 267 9.28. Template Pattern Modifiers for Date/Time Formatting .............................................. 269 9.29. Template Patterns for Numeric Formatting ............................................................. 272 9.30. Template Pattern Modifiers for Numeric Formatting ................................................. 273 9.31. to_char Examples ........................................................................................... 273 9.32. Date/Time Operators ........................................................................................... 275 9.33. Date/Time Functions ........................................................................................... 276 9.34. AT TIME ZONE Variants ................................................................................. 287 9.35. Enum Support Functions ..................................................................................... 290 9.36. Geometric Operators ........................................................................................... 291 9.37. Geometric Functions ........................................................................................... 295 9.38. Geometric Type Conversion Functions ................................................................... 296 9.39. IP Address Operators .......................................................................................... 298 9.40. IP Address Functions .......................................................................................... 299 9.41. MAC Address Functions ..................................................................................... 301 9.42. Text Search Operators ......................................................................................... 301 9.43. Text Search Functions ......................................................................................... 303 9.44. Text Search Debugging Functions ......................................................................... 307 9.45. json and jsonb Operators ................................................................................ 323 9.46. Additional jsonb Operators ................................................................................ 324 9.47. JSON Creation Functions .................................................................................... 326 9.48. SQL/JSON Testing Functions ............................................................................... 327 9.49. JSON Processing Functions ................................................................................. 328 9.50. jsonpath Operators and Methods ...................................................................... 337 9.51. jsonpath Filter Expression Elements .................................................................. 339 9.52. Sequence Functions ............................................................................................ 342 9.53. Array Operators ................................................................................................. 346 9.54. Array Functions ................................................................................................. 347 9.55. Range Operators ................................................................................................ 350 9.56. Multirange Operators .......................................................................................... 351 9.57. Range Functions ................................................................................................ 354 9.58. Multirange Functions .......................................................................................... 355 9.59. General-Purpose Aggregate Functions .................................................................... 356 9.60. Aggregate Functions for Statistics ......................................................................... 359 9.61. Ordered-Set Aggregate Functions .......................................................................... 361 9.62. Hypothetical-Set Aggregate Functions ................................................................... 362 9.63. Grouping Operations ........................................................................................... 362 9.64. General-Purpose Window Functions ...................................................................... 363 9.65. Series Generating Functions ................................................................................. 370 9.66. Subscript Generating Functions ............................................................................ 372 9.67. Session Information Functions .............................................................................. 374 9.68. Access Privilege Inquiry Functions ........................................................................ 377 9.69. aclitem Operators ........................................................................................... 379 9.70. aclitem Functions ........................................................................................... 379 9.71. Schema Visibility Inquiry Functions ...................................................................... 380 9.72. System Catalog Information Functions ................................................................... 381 9.73. Index Column Properties ..................................................................................... 386 9.74. Index Properties ................................................................................................. 386 9.75. Index Access Method Properties ........................................................................... 386 9.76. GUC Flags ........................................................................................................ 387 9.77. Object Information and Addressing Functions ......................................................... 387 9.78. Comment Information Functions ........................................................................... 388 9.79. Data Validity Checking Functions ......................................................................... 388 9.80. Transaction ID and Snapshot Information Functions ................................................. 389 9.81. Snapshot Components ......................................................................................... 390 9.82. Deprecated Transaction ID and Snapshot Information Functions ................................. 391
xxiv


PostgreSQL 16.2 Documentation
9.83. Committed Transaction Information Functions ........................................................ 391 9.84. Control Data Functions ....................................................................................... 392 9.85. pg_control_checkpoint Output Columns ...................................................... 392 9.86. pg_control_system Output Columns .............................................................. 393 9.87. pg_control_init Output Columns .................................................................. 393 9.88. pg_control_recovery Output Columns .......................................................... 393 9.89. Configuration Settings Functions .......................................................................... 394 9.90. Server Signaling Functions .................................................................................. 394 9.91. Backup Control Functions ................................................................................... 396 9.92. Recovery Information Functions ........................................................................... 398 9.93. Recovery Control Functions ................................................................................. 399 9.94. Snapshot Synchronization Functions ...................................................................... 400 9.95. Replication Management Functions ....................................................................... 401 9.96. Database Object Size Functions ............................................................................ 403 9.97. Database Object Location Functions ...................................................................... 404 9.98. Collation Management Functions .......................................................................... 405 9.99. Partitioning Information Functions ........................................................................ 405 9.100. Index Maintenance Functions ............................................................................. 406 9.101. Generic File Access Functions ............................................................................ 407 9.102. Advisory Lock Functions ................................................................................... 409 9.103. Built-In Trigger Functions .................................................................................. 410 9.104. Table Rewrite Information Functions ................................................................... 414 12.1. Default Parser's Token Types ............................................................................... 464 13.1. Transaction Isolation Levels ................................................................................. 487 13.2. Conflicting Lock Modes ...................................................................................... 494 13.3. Conflicting Row-Level Locks ............................................................................... 496 19.1. System V IPC Parameters .................................................................................... 582 19.2. SSL Server File Usage ........................................................................................ 597 20.1. synchronous_commit Modes ................................................................................ 624 20.2. Message Severity Levels ..................................................................................... 651 20.3. Keys and Values of JSON Log Entries .................................................................. 658 20.4. Short Option Key ............................................................................................... 685 22.1. Predefined Roles ................................................................................................ 714 24.1. ICU Collation Levels .......................................................................................... 733 24.2. ICU Collation Settings ........................................................................................ 734 24.3. PostgreSQL Character Sets .................................................................................. 737 24.4. Built-in Client/Server Character Set Conversions ..................................................... 742 24.5. All Built-in Character Set Conversions .................................................................. 743 27.1. High Availability, Load Balancing, and Replication Feature Matrix ............................. 776 28.1. Dynamic Statistics Views .................................................................................... 797 28.2. Collected Statistics Views .................................................................................... 798 28.3. pg_stat_activity View ............................................................................... 801 28.4. Wait Event Types .............................................................................................. 802 28.5. Wait Events of Type Activity .......................................................................... 803 28.6. Wait Events of Type BufferPin ........................................................................ 804 28.7. Wait Events of Type Client .............................................................................. 804 28.8. Wait Events of Type Extension ........................................................................ 804 28.9. Wait Events of Type IO ..................................................................................... 804 28.10. Wait Events of Type IPC .................................................................................. 807 28.11. Wait Events of Type Lock ................................................................................ 809 28.12. Wait Events of Type LWLock ............................................................................ 810 28.13. Wait Events of Type Timeout .......................................................................... 813 28.14. pg_stat_replication View ....................................................................... 814 28.15. pg_stat_replication_slots View ........................................................... 816 28.16. pg_stat_wal_receiver View ..................................................................... 817 28.17. pg_stat_recovery_prefetch View ........................................................... 818 28.18. pg_stat_subscription View ..................................................................... 818 28.19. pg_stat_subscription_stats View ......................................................... 819
xxv


PostgreSQL 16.2 Documentation
28.20. pg_stat_ssl View ....................................................................................... 820 28.21. pg_stat_gssapi View ................................................................................. 820 28.22. pg_stat_archiver View ............................................................................. 821 28.23. pg_stat_io View ......................................................................................... 821 28.24. pg_stat_bgwriter View ............................................................................. 823 28.25. pg_stat_wal View ....................................................................................... 824 28.26. pg_stat_database View ............................................................................. 825 28.27. pg_stat_database_conflicts View ......................................................... 827 28.28. pg_stat_all_tables View ......................................................................... 827 28.29. pg_stat_all_indexes View ....................................................................... 829 28.30. pg_statio_all_tables View ..................................................................... 830 28.31. pg_statio_all_indexes View ................................................................... 830 28.32. pg_statio_all_sequences View ............................................................... 831 28.33. pg_stat_user_functions View ................................................................. 831 28.34. pg_stat_slru View ..................................................................................... 832 28.35. Additional Statistics Functions ............................................................................ 832 28.36. Per-Backend Statistics Functions ......................................................................... 834 28.37. pg_stat_progress_analyze View ............................................................. 835 28.38. ANALYZE Phases ............................................................................................ 836 28.39. pg_stat_progress_cluster View ............................................................. 837 28.40. CLUSTER and VACUUM FULL Phases .............................................................. 838 28.41. pg_stat_progress_copy View ................................................................... 838 28.42. pg_stat_progress_create_index View ................................................... 839 28.43. CREATE INDEX Phases ................................................................................... 840 28.44. pg_stat_progress_vacuum View ............................................................... 841 28.45. VACUUM Phases ............................................................................................ 841 28.46. pg_stat_progress_basebackup View ....................................................... 842 28.47. Base Backup Phases ......................................................................................... 843 28.48. Built-in DTrace Probes ...................................................................................... 844 28.49. Defined Types Used in Probe Parameters ............................................................. 850 31.1. UPDATE Transformation Summary ....................................................................... 872 34.1. SSL Mode Descriptions ....................................................................................... 980 34.2. Libpq/Client SSL File Usage ................................................................................ 980 35.1. SQL-Oriented Large Object Functions .................................................................. 1000 36.1. Mapping Between PostgreSQL Data Types and C Variable Types ............................. 1016 36.2. Valid Input Formats for PGTYPESdate_from_asc ............................................ 1034 36.3. Valid Input Formats for PGTYPESdate_fmt_asc .............................................. 1036 36.4. Valid Input Formats for rdefmtdate ................................................................ 1037 36.5. Valid Input Formats for PGTYPEStimestamp_from_asc ................................... 1038 37.1. information_schema_catalog_name Columns ........................................... 1116 37.2. administrable_role_authorizations Columns ....................................... 1116 37.3. applicable_roles Columns ........................................................................ 1116 37.4. attributes Columns .................................................................................... 1117 37.5. character_sets Columns ............................................................................ 1119 37.6. check_constraint_routine_usage Columns ............................................. 1120 37.7. check_constraints Columns ...................................................................... 1120 37.8. collations Columns .................................................................................... 1121 37.9. collation_character_set_applicability Columns ............................... 1121 37.10. column_column_usage Columns ................................................................. 1122 37.11. column_domain_usage Columns ................................................................. 1122 37.12. column_options Columns ........................................................................... 1123 37.13. column_privileges Columns ..................................................................... 1123 37.14. column_udt_usage Columns ....................................................................... 1124 37.15. columns Columns ......................................................................................... 1124 37.16. constraint_column_usage Columns ......................................................... 1127 37.17. constraint_table_usage Columns ........................................................... 1128 37.18. data_type_privileges Columns ............................................................... 1129 37.19. domain_constraints Columns ................................................................... 1129
xxvi


PostgreSQL 16.2 Documentation
37.20. domain_udt_usage Columns ....................................................................... 1130 37.21. domains Columns ......................................................................................... 1130 37.22. element_types Columns ............................................................................. 1132 37.23. enabled_roles Columns ............................................................................. 1134 37.24. foreign_data_wrapper_options Columns ............................................... 1134 37.25. foreign_data_wrappers Columns ............................................................. 1135 37.26. foreign_server_options Columns ........................................................... 1135 37.27. foreign_servers Columns ......................................................................... 1135 37.28. foreign_table_options Columns ............................................................. 1136 37.29. foreign_tables Columns ........................................................................... 1136 37.30. key_column_usage Columns ....................................................................... 1137 37.31. parameters Columns ................................................................................... 1137 37.32. referential_constraints Columns ......................................................... 1139 37.33. role_column_grants Columns ................................................................... 1140 37.34. role_routine_grants Columns ................................................................. 1140 37.35. role_table_grants Columns ..................................................................... 1141 37.36. role_udt_grants Columns ......................................................................... 1142 37.37. role_usage_grants Columns ..................................................................... 1142 37.38. routine_column_usage Columns ............................................................... 1143 37.39. routine_privileges Columns ................................................................... 1144 37.40. routine_routine_usage Columns ............................................................. 1144 37.41. routine_sequence_usage Columns ........................................................... 1145 37.42. routine_table_usage Columns ................................................................. 1145 37.43. routines Columns ....................................................................................... 1146 37.44. schemata Columns ....................................................................................... 1150 37.45. sequences Columns ..................................................................................... 1151 37.46. sql_features Columns ............................................................................... 1151 37.47. sql_implementation_info Columns ......................................................... 1152 37.48. sql_parts Columns ..................................................................................... 1152 37.49. sql_sizing Columns ................................................................................... 1153 37.50. table_constraints Columns ..................................................................... 1153 37.51. table_privileges Columns ....................................................................... 1154 37.52. tables Columns ........................................................................................... 1155 37.53. transforms Columns ................................................................................... 1155 37.54. triggered_update_columns Columns ....................................................... 1156 37.55. triggers Columns ....................................................................................... 1156 37.56. udt_privileges Columns ........................................................................... 1158 37.57. usage_privileges Columns ....................................................................... 1159 37.58. user_defined_types Columns ................................................................... 1159 37.59. user_mapping_options Columns ............................................................... 1161 37.60. user_mappings Columns ............................................................................. 1161 37.61. view_column_usage Columns ..................................................................... 1162 37.62. view_routine_usage Columns ................................................................... 1162 37.63. view_table_usage Columns ....................................................................... 1163 37.64. views Columns ............................................................................................. 1163 38.1. Polymorphic Types ........................................................................................... 1172 38.2. Equivalent C Types for Built-in SQL Types .......................................................... 1198 38.3. B-Tree Strategies .............................................................................................. 1234 38.4. Hash Strategies ................................................................................................ 1234 38.5. GiST Two-Dimensional “R-tree” Strategies ........................................................... 1234 38.6. SP-GiST Point Strategies ................................................................................... 1234 38.7. GIN Array Strategies ........................................................................................ 1235 38.8. BRIN Minmax Strategies ................................................................................... 1235 38.9. B-Tree Support Functions .................................................................................. 1236 38.10. Hash Support Functions ................................................................................... 1236 38.11. GiST Support Functions ................................................................................... 1236 38.12. SP-GiST Support Functions .............................................................................. 1237 38.13. GIN Support Functions .................................................................................... 1237
xxvii


PostgreSQL 16.2 Documentation
38.14. BRIN Support Functions .................................................................................. 1238 40.1. Event Trigger Support by Command Tag .............................................................. 1270 43.1. Available Diagnostics Items ............................................................................... 1324 43.2. Error Diagnostics Items ..................................................................................... 1338 292. Policies Applied by Command Type ..................................................................... 1734 293. pgbench Automatic Variables .............................................................................. 2071 294. pgbench Operators ............................................................................................. 2073 295. pgbench Functions ............................................................................................. 2075 53.1. System Catalogs ............................................................................................... 2247 53.2. pg_aggregate Columns ................................................................................ 2249 53.3. pg_am Columns .............................................................................................. 2250 53.4. pg_amop Columns .......................................................................................... 2251 53.5. pg_amproc Columns ...................................................................................... 2252 53.6. pg_attrdef Columns .................................................................................... 2252 53.7. pg_attribute Columns ................................................................................ 2253 53.8. pg_authid Columns ...................................................................................... 2255 53.9. pg_auth_members Columns .......................................................................... 2256 53.10. pg_cast Columns ......................................................................................... 2257 53.11. pg_class Columns ....................................................................................... 2257 53.12. pg_collation Columns ............................................................................... 2260 53.13. pg_constraint Columns ............................................................................. 2261 53.14. pg_conversion Columns ............................................................................. 2262 53.15. pg_database Columns ................................................................................. 2263 53.16. pg_db_role_setting Columns ................................................................... 2264 53.17. pg_default_acl Columns ........................................................................... 2265 53.18. pg_depend Columns ..................................................................................... 2265 53.19. pg_description Columns ........................................................................... 2267 53.20. pg_enum Columns ......................................................................................... 2268 53.21. pg_event_trigger Columns ....................................................................... 2268 53.22. pg_extension Columns ............................................................................... 2269 53.23. pg_foreign_data_wrapper Columns ......................................................... 2269 53.24. pg_foreign_server Columns ..................................................................... 2270 53.25. pg_foreign_table Columns ....................................................................... 2270 53.26. pg_index Columns ....................................................................................... 2271 53.27. pg_inherits Columns ................................................................................. 2272 53.28. pg_init_privs Columns ............................................................................. 2273 53.29. pg_language Columns ................................................................................. 2273 53.30. pg_largeobject Columns ........................................................................... 2274 53.31. pg_largeobject_metadata Columns ......................................................... 2274 53.32. pg_namespace Columns ............................................................................... 2275 53.33. pg_opclass Columns ................................................................................... 2275 53.34. pg_operator Columns ................................................................................. 2276 53.35. pg_opfamily Columns ................................................................................. 2277 53.36. pg_parameter_acl Columns ....................................................................... 2277 53.37. pg_partitioned_table Columns ............................................................... 2277 53.38. pg_policy Columns ..................................................................................... 2278 53.39. pg_proc Columns ......................................................................................... 2279 53.40. pg_publication Columns ........................................................................... 2281 53.41. pg_publication_namespace Columns ....................................................... 2282 53.42. pg_publication_rel Columns ................................................................... 2282 53.43. pg_range Columns ....................................................................................... 2283 53.44. pg_replication_origin Columns ............................................................. 2283 53.45. pg_rewrite Columns ................................................................................... 2283 53.46. pg_seclabel Columns ................................................................................. 2284 53.47. pg_sequence Columns ................................................................................. 2285 53.48. pg_shdepend Columns ................................................................................. 2285 53.49. pg_shdescription Columns ....................................................................... 2286 53.50. pg_shseclabel Columns ............................................................................. 2287
xxviii


PostgreSQL 16.2 Documentation
53.51. pg_statistic Columns ............................................................................... 2288 53.52. pg_statistic_ext Columns ....................................................................... 2289 53.53. pg_statistic_ext_data Columns ............................................................. 2290 53.54. pg_subscription Columns ......................................................................... 2290 53.55. pg_subscription_rel Columns ................................................................. 2291 53.56. pg_tablespace Columns ............................................................................. 2292 53.57. pg_transform Columns ............................................................................... 2292 53.58. pg_trigger Columns ................................................................................... 2292 53.59. pg_ts_config Columns ............................................................................... 2294 53.60. pg_ts_config_map Columns ....................................................................... 2294 53.61. pg_ts_dict Columns ................................................................................... 2295 53.62. pg_ts_parser Columns ............................................................................... 2295 53.63. pg_ts_template Columns ........................................................................... 2296 53.64. pg_type Columns ......................................................................................... 2296 53.65. typcategory Codes .................................................................................... 2299 53.66. pg_user_mapping Columns ......................................................................... 2300 54.1. System Views .................................................................................................. 2301 54.2. pg_available_extensions Columns .......................................................... 2302 54.3. pg_available_extension_versions Columns ........................................... 2302 54.4. pg_backend_memory_contexts Columns ..................................................... 2303 54.5. pg_config Columns ...................................................................................... 2304 54.6. pg_cursors Columns .................................................................................... 2304 54.7. pg_file_settings Columns ........................................................................ 2305 54.8. pg_group Columns ........................................................................................ 2306 54.9. pg_hba_file_rules Columns ...................................................................... 2306 54.10. pg_ident_file_mappings Columns ........................................................... 2307 54.11. pg_indexes Columns ................................................................................... 2307 54.12. pg_locks Columns ....................................................................................... 2308 54.13. pg_matviews Columns ................................................................................. 2311 54.14. pg_policies Columns ................................................................................. 2311 54.15. pg_prepared_statements Columns ........................................................... 2312 54.16. pg_prepared_xacts Columns ..................................................................... 2312 54.17. pg_publication_tables Columns ............................................................. 2313 54.18. pg_replication_origin_status Columns ............................................... 2313 54.19. pg_replication_slots Columns ............................................................... 2314 54.20. pg_roles Columns ....................................................................................... 2315 54.21. pg_rules Columns ....................................................................................... 2316 54.22. pg_seclabels Columns ............................................................................... 2316 54.23. pg_sequences Columns ............................................................................... 2317 54.24. pg_settings Columns ................................................................................. 2318 54.25. pg_shadow Columns ..................................................................................... 2320 54.26. pg_shmem_allocations Columns ............................................................... 2320 54.27. pg_stats Columns ....................................................................................... 2321 54.28. pg_stats_ext Columns ............................................................................... 2322 54.29. pg_stats_ext_exprs Columns ................................................................... 2324 54.30. pg_tables Columns ..................................................................................... 2325 54.31. pg_timezone_abbrevs Columns ................................................................. 2326 54.32. pg_timezone_names Columns ..................................................................... 2326 54.33. pg_user Columns ......................................................................................... 2326 54.34. pg_user_mappings Columns ....................................................................... 2327 54.35. pg_views Columns ....................................................................................... 2328 68.1. Built-in GiST Operator Classes ........................................................................... 2466 69.1. Built-in SP-GiST Operator Classes ...................................................................... 2484 70.1. Built-in GIN Operator Classes ............................................................................ 2497 71.1. Built-in BRIN Operator Classes .......................................................................... 2505 71.2. Function and Support Numbers for Minmax Operator Classes ................................... 2514 71.3. Function and Support Numbers for Inclusion Operator Classes ................................. 2514 71.4. Procedure and Support Numbers for Bloom Operator Classes ................................... 2515
xxix


PostgreSQL 16.2 Documentation
71.5. Procedure and Support Numbers for minmax-multi Operator Classes ......................... 2516 73.1. Contents of PGDATA ......................................................................................... 2519 73.2. Page Layout .................................................................................................... 2525 73.3. PageHeaderData Layout ..................................................................................... 2526 73.4. HeapTupleHeaderData Layout ............................................................................ 2527 A.1. PostgreSQL Error Codes ..................................................................................... 2559 B.1. Month Names ................................................................................................... 2570 B.2. Day of the Week Names ..................................................................................... 2570 B.3. Date/Time Field Modifiers .................................................................................. 2570 C.1. SQL Key Words ................................................................................................ 2576 F.1. adminpack Functions ....................................................................................... 2661 F.2. Cube External Representations ............................................................................. 2685 F.3. Cube Operators .................................................................................................. 2685 F.4. Cube Functions .................................................................................................. 2686 F.5. Cube-Based Earthdistance Functions ..................................................................... 2725 F.6. Point-Based Earthdistance Operators ..................................................................... 2726 F.7. hstore Operators ............................................................................................. 2736 F.8. hstore Functions ............................................................................................. 2737 F.9. intarray Functions ......................................................................................... 2745 F.10. intarray Operators ....................................................................................... 2746 F.11. isn Data Types ............................................................................................... 2749 F.12. isn Functions ................................................................................................. 2750 F.13. ltree Operators ............................................................................................. 2756 F.14. ltree Functions ............................................................................................. 2758 F.15. pg_buffercache Columns ............................................................................ 2776 F.16. pg_buffercache_summary() Output Columns .............................................. 2777 F.17. pg_buffercache_usage_counts() Output Columns .................................... 2777 F.18. Supported Algorithms for crypt() ................................................................... 2781 F.19. Iteration Counts for crypt() ........................................................................... 2781 F.20. Hash Algorithm Speeds ..................................................................................... 2782 F.21. pgrowlocks Output Columns .......................................................................... 2795 F.22. pg_stat_statements Columns .................................................................... 2797 F.23. pg_stat_statements_info Columns .......................................................... 2801 F.24. pgstattuple Output Columns ........................................................................ 2805 F.25. pgstattuple_approx Output Columns .......................................................... 2808 F.26. pg_trgm Functions ......................................................................................... 2812 F.27. pg_trgm Operators ......................................................................................... 2813 F.28. seg External Representations ............................................................................. 2835 F.29. Examples of Valid seg Input ............................................................................. 2835 F.30. Seg GiST Operators .......................................................................................... 2835 F.31. Sepgsql Functions ............................................................................................ 2843 F.32. tablefunc Functions ..................................................................................... 2849 F.33. connectby Parameters ................................................................................... 2856 F.34. Functions for UUID Generation .......................................................................... 2867 F.35. Functions Returning UUID Constants .................................................................. 2868 F.36. xml2 Functions ............................................................................................... 2869 F.37. xpath_table Parameters ............................................................................... 2870 K.1. PostgreSQL Limitations ...................................................................................... 2891
xxx


List of Examples
8.1. Using the Character Types .................................................................................... 155 8.2. Using the boolean Type ..................................................................................... 168 8.3. Using the Bit String Types .................................................................................... 176 9.1. XSLT Stylesheet for Converting SQL/XML Output to HTML ..................................... 321 10.1. Square Root Operator Type Resolution .................................................................. 418 10.2. String Concatenation Operator Type Resolution ....................................................... 419 10.3. Absolute-Value and Negation Operator Type Resolution ........................................... 419 10.4. Array Inclusion Operator Type Resolution .............................................................. 420 10.5. Custom Operator on a Domain Type ..................................................................... 420 10.6. Rounding Function Argument Type Resolution ....................................................... 423 10.7. Variadic Function Resolution ............................................................................... 423 10.8. Substring Function Type Resolution ...................................................................... 424 10.9. character Storage Type Conversion .................................................................. 425 10.10. Type Resolution with Underspecified Types in a Union ........................................... 426 10.11. Type Resolution in a Simple Union ..................................................................... 426 10.12. Type Resolution in a Transposed Union ............................................................... 427 10.13. Type Resolution in a Nested Union ..................................................................... 427 11.1. Setting up a Partial Index to Exclude Common Values .............................................. 436 11.2. Setting up a Partial Index to Exclude Uninteresting Values ........................................ 437 11.3. Setting up a Partial Unique Index ......................................................................... 438 11.4. Do Not Use Partial Indexes as a Substitute for Partitioning ........................................ 438 21.1. Example pg_hba.conf Entries .......................................................................... 693 21.2. An Example pg_ident.conf File ..................................................................... 697 34.1. libpq Example Program 1 .................................................................................... 984 34.2. libpq Example Program 2 .................................................................................... 986 34.3. libpq Example Program 3 .................................................................................... 989 35.1. Large Objects with libpq Example Program .......................................................... 1001 36.1. Example SQLDA Program ................................................................................. 1054 36.2. ECPG Program Accessing Large Objects .............................................................. 1068 42.1. Manual Installation of PL/Perl ............................................................................ 1305 43.1. Quoting Values in Dynamic Queries .................................................................... 1322 43.2. Exceptions with UPDATE/INSERT ...................................................................... 1337 43.3. A PL/pgSQL Trigger Function ............................................................................ 1351 43.4. A PL/pgSQL Trigger Function for Auditing .......................................................... 1352 43.5. A PL/pgSQL View Trigger Function for Auditing .................................................. 1353 43.6. A PL/pgSQL Trigger Function for Maintaining a Summary Table ............................. 1354 43.7. Auditing with Transition Tables .......................................................................... 1356 43.8. A PL/pgSQL Event Trigger Function ................................................................... 1358 43.9. Porting a Simple Function from PL/SQL to PL/pgSQL ............................................ 1366 43.10. Porting a Function that Creates Another Function from PL/SQL to PL/pgSQL ............ 1367 43.11. Porting a Procedure With String Manipulation and OUT Parameters from PL/SQL to PL/pgSQL ............................................................................................................... 1368 43.12. Porting a Procedure from PL/SQL to PL/pgSQL .................................................. 1370 F.1. Create a Foreign Table for PostgreSQL CSV Logs ................................................... 2728
xxxi


Preface
This book is the official documentation of PostgreSQL. It has been written by the PostgreSQL developers and other volunteers in parallel to the development of the PostgreSQL software. It describes all the functionality that the current version of PostgreSQL officially supports.
To make the large amount of information about PostgreSQL manageable, this book has been organized in several parts. Each part is targeted at a different class of users, or at users in different stages of their PostgreSQL experience:
• Part I is an informal introduction for new users.
• Part II documents the SQL query language environment, including data types and functions, as well as user-level performance tuning. Every PostgreSQL user should read this.
• Part III describes the installation and administration of the server. Everyone who runs a PostgreSQL server, be it for private use or for others, should read this part.
• Part IV describes the programming interfaces for PostgreSQL client programs.
• Part V contains information for advanced users about the extensibility capabilities of the server. Topics include user-defined data types and functions.
• Part VI contains reference information about SQL commands, client and server programs. This part supports the other parts with structured information sorted by command or program.
• Part VII contains assorted information that might be of use to PostgreSQL developers.
1. What Is PostgreSQL?
PostgreSQL is an object-relational database management system (ORDBMS) based on POSTGRES,
Version 4.21, developed at the University of California at Berkeley Computer Science Department. POSTGRES pioneered many concepts that only became available in some commercial database systems much later.
PostgreSQL is an open-source descendant of this original Berkeley code. It supports a large part of the SQL standard and offers many modern features:
• complex queries • foreign keys • triggers • updatable views • transactional integrity • multiversion concurrency control
Also, PostgreSQL can be extended by the user in many ways, for example by adding new
• data types • functions • operators • aggregate functions • index methods • procedural languages
And because of the liberal license, PostgreSQL can be used, modified, and distributed by anyone free of charge for any purpose, be it private, commercial, or academic.
2. A Brief History of PostgreSQL
1 https://dsf.berkeley.edu/postgres.html
xxxii


Preface
The object-relational database management system now known as PostgreSQL is derived from the POSTGRES package written at the University of California at Berkeley. With decades of development behind it, PostgreSQL is now the most advanced open-source database available anywhere.
2.1. The Berkeley POSTGRES Project
The POSTGRES project, led by Professor Michael Stonebraker, was sponsored by the Defense Advanced Research Projects Agency (DARPA), the Army Research Office (ARO), the National Science Foundation (NSF), and ESL, Inc. The implementation of POSTGRES began in 1986. The initial concepts for the system were presented in [ston86], and the definition of the initial data model appeared in [rowe87]. The design of the rule system at that time was described in [ston87a]. The rationale and architecture of the storage manager were detailed in [ston87b].
POSTGRES has undergone several major releases since then. The first “demoware” system became operational in 1987 and was shown at the 1988 ACM-SIGMOD Conference. Version 1, described in [ston90a], was released to a few external users in June 1989. In response to a critique of the first rule system ([ston89]), the rule system was redesigned ([ston90b]), and Version 2 was released in June 1990 with the new rule system. Version 3 appeared in 1991 and added support for multiple storage managers, an improved query executor, and a rewritten rule system. For the most part, subsequent releases until Postgres95 (see below) focused on portability and reliability.
POSTGRES has been used to implement many different research and production applications. These include: a financial data analysis system, a jet engine performance monitoring package, an asteroid tracking database, a medical information database, and several geographic information systems. POSTGRES has also been used as an educational tool at several universities. Finally, Illustra Infor
mation Technologies (later merged into Informix2, which is now owned by IBM3) picked up the code and commercialized it. In late 1992, POSTGRES became the primary data manager for the Sequoia
2000 scientific computing project4.
The size of the external user community nearly doubled during 1993. It became increasingly obvious that maintenance of the prototype code and support was taking up large amounts of time that should have been devoted to database research. In an effort to reduce this support burden, the Berkeley POSTGRES project officially ended with Version 4.2.
2.2. Postgres95
In 1994, Andrew Yu and Jolly Chen added an SQL language interpreter to POSTGRES. Under a new name, Postgres95 was subsequently released to the web to find its own way in the world as an opensource descendant of the original POSTGRES Berkeley code.
Postgres95 code was completely ANSI C and trimmed in size by 25%. Many internal changes improved performance and maintainability. Postgres95 release 1.0.x ran about 30–50% faster on the Wisconsin Benchmark compared to POSTGRES, Version 4.2. Apart from bug fixes, the following were the major enhancements:
• The query language PostQUEL was replaced with SQL (implemented in the server). (Interface library libpq was named after PostQUEL.) Subqueries were not supported until PostgreSQL (see below), but they could be imitated in Postgres95 with user-defined SQL functions. Aggregate functions were re-implemented. Support for the GROUP BY query clause was also added.
• A new program (psql) was provided for interactive SQL queries, which used GNU Readline. This largely superseded the old monitor program.
• A new front-end library, libpgtcl, supported Tcl-based clients. A sample shell, pgtclsh, provided new Tcl commands to interface Tcl programs with the Postgres95 server.
2 https://www.ibm.com/analytics/informix
3 https://www.ibm.com/
4 http://meteora.ucsd.edu/s2k/s2k_home.html
xxxiii


Preface
• The large-object interface was overhauled. The inversion large objects were the only mechanism for storing large objects. (The inversion file system was removed.)
• The instance-level rule system was removed. Rules were still available as rewrite rules.
• A short tutorial introducing regular SQL features as well as those of Postgres95 was distributed with the source code
• GNU make (instead of BSD make) was used for the build. Also, Postgres95 could be compiled with an unpatched GCC (data alignment of doubles was fixed).
2.3. PostgreSQL
By 1996, it became clear that the name “Postgres95” would not stand the test of time. We chose a new name, PostgreSQL, to reflect the relationship between the original POSTGRES and the more recent versions with SQL capability. At the same time, we set the version numbering to start at 6.0, putting the numbers back into the sequence originally begun by the Berkeley POSTGRES project.
Many people continue to refer to PostgreSQL as “Postgres” (now rarely in all capital letters) because of tradition or because it is easier to pronounce. This usage is widely accepted as a nickname or alias.
The emphasis during development of Postgres95 was on identifying and understanding existing problems in the server code. With PostgreSQL, the emphasis has shifted to augmenting features and capabilities, although work continues in all areas.
Details about what has happened in PostgreSQL since then can be found in Appendix E.
3. Conventions
The following conventions are used in the synopsis of a command: brackets ([ and ]) indicate optional parts. Braces ({ and }) and vertical lines (|) indicate that you must choose one alternative. Dots (...) mean that the preceding element can be repeated. All other symbols, including parentheses, should be taken literally.
Where it enhances the clarity, SQL commands are preceded by the prompt =>, and shell commands are preceded by the prompt $. Normally, prompts are not shown, though.
An administrator is generally a person who is in charge of installing and running the server. A user could be anyone who is using, or wants to use, any part of the PostgreSQL system. These terms should not be interpreted too narrowly; this book does not have fixed presumptions about system administration procedures.
4. Further Information
Besides the documentation, that is, this book, there are other resources about PostgreSQL:
Wiki
The PostgreSQL wiki5 contains the project's FAQ6 (Frequently Asked Questions) list, TODO7 list, and detailed information about many more topics.
Web Site
The PostgreSQL web site8 carries details on the latest release and other information to make your work or play with PostgreSQL more productive.
5 https://wiki.postgresql.org
6 https://wiki.postgresql.org/wiki/Frequently_Asked_Questions
7 https://wiki.postgresql.org/wiki/Todo
8 https://www.postgresql.org
xxxiv


Preface
Mailing Lists
The mailing lists are a good place to have your questions answered, to share experiences with other users, and to contact the developers. Consult the PostgreSQL web site for details.
Yourself!
PostgreSQL is an open-source project. As such, it depends on the user community for ongoing support. As you begin to use PostgreSQL, you will rely on others for help, either through the documentation or through the mailing lists. Consider contributing your knowledge back. Read the mailing lists and answer questions. If you learn something which is not in the documentation, write it up and contribute it. If you add features to the code, contribute them.
5. Bug Reporting Guidelines
When you find a bug in PostgreSQL we want to hear about it. Your bug reports play an important part in making PostgreSQL more reliable because even the utmost care cannot guarantee that every part of PostgreSQL will work on every platform under every circumstance.
The following suggestions are intended to assist you in forming bug reports that can be handled in an effective fashion. No one is required to follow them but doing so tends to be to everyone's advantage.
We cannot promise to fix every bug right away. If the bug is obvious, critical, or affects a lot of users, chances are good that someone will look into it. It could also happen that we tell you to update to a newer version to see if the bug happens there. Or we might decide that the bug cannot be fixed before some major rewrite we might be planning is done. Or perhaps it is simply too hard and there are more important things on the agenda. If you need help immediately, consider obtaining a commercial support contract.
5.1. Identifying Bugs
Before you report a bug, please read and re-read the documentation to verify that you can really do whatever it is you are trying. If it is not clear from the documentation whether you can do something or not, please report that too; it is a bug in the documentation. If it turns out that a program does something different from what the documentation says, that is a bug. That might include, but is not limited to, the following circumstances:
• A program terminates with a fatal signal or an operating system error message that would point to a problem in the program. (A counterexample might be a “disk full” message, since you have to fix that yourself.)
• A program produces the wrong output for any given input.
• A program refuses to accept valid input (as defined in the documentation).
• A program accepts invalid input without a notice or error message. But keep in mind that your idea of invalid input might be our idea of an extension or compatibility with traditional practice.
• PostgreSQL fails to compile, build, or install according to the instructions on supported platforms.
Here “program” refers to any executable, not only the backend process.
Being slow or resource-hogging is not necessarily a bug. Read the documentation or ask on one of the mailing lists for help in tuning your applications. Failing to comply to the SQL standard is not necessarily a bug either, unless compliance for the specific feature is explicitly claimed.
Before you continue, check on the TODO list and in the FAQ to see if your bug is already known. If you cannot decode the information on the TODO list, report your problem. The least we can do is make the TODO list clearer.
xxxv


Preface
5.2. What to Report
The most important thing to remember about bug reporting is to state all the facts and only facts. Do not speculate what you think went wrong, what “it seemed to do”, or which part of the program has a fault. If you are not familiar with the implementation you would probably guess wrong and not help us a bit. And even if you are, educated explanations are a great supplement to but no substitute for facts. If we are going to fix the bug we still have to see it happen for ourselves first. Reporting the bare facts is relatively straightforward (you can probably copy and paste them from the screen) but all too often important details are left out because someone thought it does not matter or the report would be understood anyway.
The following items should be contained in every bug report:
• The exact sequence of steps from program start-up necessary to reproduce the problem. This should be self-contained; it is not enough to send in a bare SELECT statement without the preceding CREATE TABLE and INSERT statements, if the output should depend on the data in the tables. We do not have the time to reverse-engineer your database schema, and if we are supposed to make up our own data we would probably miss the problem.
The best format for a test case for SQL-related problems is a file that can be run through the psql frontend that shows the problem. (Be sure to not have anything in your ~/.psqlrc start-up file.) An easy way to create this file is to use pg_dump to dump out the table declarations and data needed to set the scene, then add the problem query. You are encouraged to minimize the size of your example, but this is not absolutely necessary. If the bug is reproducible, we will find it either way.
If your application uses some other client interface, such as PHP, then please try to isolate the offending queries. We will probably not set up a web server to reproduce your problem. In any case remember to provide the exact input files; do not guess that the problem happens for “large files” or “midsize databases”, etc. since this information is too inexact to be of use.
• The output you got. Please do not say that it “didn't work” or “crashed”. If there is an error message, show it, even if you do not understand it. If the program terminates with an operating system error, say which. If nothing at all happens, say so. Even if the result of your test case is a program crash or otherwise obvious it might not happen on our platform. The easiest thing is to copy the output from the terminal, if possible.
Note
If you are reporting an error message, please obtain the most verbose form of the message. In psql, say \set VERBOSITY verbose beforehand. If you are extracting the message from the server log, set the run-time parameter log_error_verbosity to verbose so that all details are logged.
Note
In case of fatal errors, the error message reported by the client might not contain all the information available. Please also look at the log output of the database server. If you do not keep your server's log output, this would be a good time to start doing so.
• The output you expected is very important to state. If you just write “This command gives me that output.” or “This is not what I expected.”, we might run it ourselves, scan the output, and think it looks OK and is exactly what we expected. We should not have to spend the time to decode the exact semantics behind your commands. Especially refrain from merely saying that “This is not what SQL says/Oracle does.” Digging out the correct behavior from SQL is not a fun undertaking,
xxxvi


Preface
nor do we all know how all the other relational databases out there behave. (If your problem is a program crash, you can obviously omit this item.)
• Any command line options and other start-up options, including any relevant environment variables or configuration files that you changed from the default. Again, please provide exact information. If you are using a prepackaged distribution that starts the database server at boot time, you should try to find out how that is done.
• Anything you did at all differently from the installation instructions.
• The PostgreSQL version. You can run the command SELECT version(); to find out the version of the server you are connected to. Most executable programs also support a --version option; at least postgres --version and psql --version should work. If the function or the options do not exist then your version is more than old enough to warrant an upgrade. If you run a prepackaged version, such as RPMs, say so, including any subversion the package might have. If you are talking about a Git snapshot, mention that, including the commit hash.
If your version is older than 16.2 we will almost certainly tell you to upgrade. There are many bug fixes and improvements in each new release, so it is quite possible that a bug you have encountered in an older release of PostgreSQL has already been fixed. We can only provide limited support for sites using older releases of PostgreSQL; if you require more than we can provide, consider acquiring a commercial support contract.
• Platform information. This includes the kernel name and version, C library, processor, memory information, and so on. In most cases it is sufficient to report the vendor and version, but do not assume everyone knows what exactly “Debian” contains or that everyone runs on x86_64. If you have installation problems then information about the toolchain on your machine (compiler, make, and so on) is also necessary.
Do not be afraid if your bug report becomes rather lengthy. That is a fact of life. It is better to report everything the first time than us having to squeeze the facts out of you. On the other hand, if your input files are huge, it is fair to ask first whether somebody is interested in looking into it. Here is an
article9 that outlines some more tips on reporting bugs.
Do not spend all your time to figure out which changes in the input make the problem go away. This will probably not help solving it. If it turns out that the bug cannot be fixed right away, you will still have time to find and share your work-around. Also, once again, do not waste your time guessing why the bug exists. We will find that out soon enough.
When writing a bug report, please avoid confusing terminology. The software package in total is called “PostgreSQL”, sometimes “Postgres” for short. If you are specifically talking about the backend process, mention that, do not just say “PostgreSQL crashes”. A crash of a single backend process is quite different from crash of the parent “postgres” process; please don't say “the server crashed” when you mean a single backend process went down, nor vice versa. Also, client programs such as the interactive frontend “psql” are completely separate from the backend. Please try to be specific about whether the problem is on the client or server side.
5.3. Where to Report Bugs
In general, send bug reports to the bug report mailing list at <pgsql-bugs@lists.postgresql.org>. You are requested to use a descriptive subject for your email message, perhaps parts of the error message.
Another method is to fill in the bug report web-form available at the project's web site10. Entering a bug report this way causes it to be mailed to the <pgsql-bugs@lists.postgresql.org> mailing list.
9 https://www.chiark.greenend.org.uk/~sgtatham/bugs.html
10 https://www.postgresql.org/
xxxvii


Preface
If your bug report has security implications and you'd prefer that it not become immediately visible in public archives, don't send it to pgsql-bugs. Security issues can be reported privately to <security@postgresql.org>.
Do not send bug reports to any of the user mailing lists, such as <pgsql-sql@lists.postgresql.org> or <pgsql-general@lists.postgresql.org>. These mailing lists are for answering user questions, and their subscribers normally do not wish to receive bug reports. More importantly, they are unlikely to fix them.
Also, please do not send reports to the developers' mailing list <pgsql-hackers@lists.postgresql.org>. This list is for discussing the development of PostgreSQL, and it would be nice if we could keep the bug reports separate. We might choose to take up a discussion about your bug report on pgsql-hackers, if the problem needs more review.
If you have a problem with the documentation, the best place to report it is the documentation mailing list <pgsql-docs@lists.postgresql.org>. Please be specific about what part of the documentation you are unhappy with.
If your bug is a portability problem on a non-supported platform, send mail to <pgsql-hackers@lists.postgresql.org>, so we (and you) can work on porting PostgreSQL to your platform.
Note
Due to the unfortunate amount of spam going around, all of the above lists will be moderated unless you are subscribed. That means there will be some delay before the email is delivered. If you wish to subscribe to the lists, please visit https://lists.postgresql.org/ for instructions.
xxxviii


Part I. Tutorial
Welcome to the PostgreSQL Tutorial. The following few chapters are intended to give a simple introduction to PostgreSQL, relational database concepts, and the SQL language to those who are new to any one of these aspects. We only assume some general knowledge about how to use computers. No particular Unix or programming experience is required. This part is mainly intended to give you some hands-on experience with important aspects of the PostgreSQL system. It makes no attempt to be a complete or thorough treatment of the topics it covers.
After you have worked through this tutorial you might want to move on to reading Part II to gain a more formal knowledge of the SQL language, or Part IV for information about developing applications for PostgreSQL. Those who set up and manage their own server should also read Part III.


Table of Contents
1. Getting Started .......................................................................................................... 3 1.1. Installation ..................................................................................................... 3 1.2. Architectural Fundamentals ............................................................................... 3 1.3. Creating a Database ......................................................................................... 3 1.4. Accessing a Database ...................................................................................... 5 2. The SQL Language .................................................................................................... 7 2.1. Introduction .................................................................................................... 7 2.2. Concepts ........................................................................................................ 7 2.3. Creating a New Table ...................................................................................... 7 2.4. Populating a Table With Rows .......................................................................... 8 2.5. Querying a Table ............................................................................................ 9 2.6. Joins Between Tables ..................................................................................... 11 2.7. Aggregate Functions ...................................................................................... 13 2.8. Updates ....................................................................................................... 15 2.9. Deletions ...................................................................................................... 15 3. Advanced Features ................................................................................................... 17 3.1. Introduction .................................................................................................. 17 3.2. Views .......................................................................................................... 17 3.3. Foreign Keys ................................................................................................ 17 3.4. Transactions ................................................................................................. 18 3.5. Window Functions ......................................................................................... 20 3.6. Inheritance ................................................................................................... 23 3.7. Conclusion ................................................................................................... 24
2


Chapter 1. Getting Started
1.1. Installation
Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.
If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.
If you are installing PostgreSQL yourself, then refer to Chapter 17 for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.
If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the PGHOST environment variable to the name of the database server machine. The environment variable PGPORT might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.
1.2. Architectural Fundamentals
Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.
In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):
• A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called postgres.
• The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.
As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.
The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (“forks”) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original postgres process. Thus, the supervisor server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)
1.3. Creating a Database
3


Getting Started
The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.
Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.
To create a new database, in this example named mydb, you use the following command:
$ createdb mydb
If this produces no response then this step was successful and you can skip over the remainder of this section.
If you see a message similar to:
createdb: command not found
then PostgreSQL was not installed properly. Either it was not installed at all or your shell's search path was not set to include it. Try calling the command with an absolute path instead:
$ /usr/local/pgsql/bin/createdb mydb
The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.
Another response could be this:
createdb: error: connection to server on socket "/ tmp/.s.PGSQL.5432" failed: No such file or directory Is the server running locally and accepting connections on that socket?
This means that the server was not started, or it is not listening where createdb expects to contact it. Again, check the installation instructions or consult the administrator.
Another response could be this:
createdb: error: connection to server on socket "/ tmp/.s.PGSQL.5432" failed: FATAL: role "joe" does not exist
where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see Chapter 22 for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually postgres) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the -U switch or set the PGUSER environment variable to specify your PostgreSQL user name.
If you have a user account but it does not have the privileges required to create a database, you will see the following:
createdb: error: database creation failed: ERROR: permission denied to create database
4


Getting Started
Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the
purposes of this tutorial under the user account that you started the server as. 1
You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:
$ createdb
If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database mydb, you can destroy it using the following command:
$ dropdb mydb
(For this command, the database name does not default to the user account name. You always need to specify it.) This action physically removes all files associated with the database and cannot be undone, so this should only be done with a great deal of forethought.
More about createdb and dropdb can be found in createdb and dropdb respectively.
1.4. Accessing a Database
Once you have created a database, you can access it by:
• Running the PostgreSQL interactive terminal program, called psql, which allows you to interactively enter, edit, and execute SQL commands. • Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial. • Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in Part IV.
You probably want to start up psql to try the examples in this tutorial. It can be activated for the mydb database by typing the command:
$ psql mydb
If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using createdb.
In psql, you will be greeted with the following message:
psql (16.2) Type "help" for help.
mydb=>
The last line could also be:
1 As an explanation for why this works: PostgreSQL user names are separate from operating system user accounts. When you connect to a database, you can choose what PostgreSQL user name to connect as; if you don't, it will default to the same name as your current operating system account. As it happens, there will always be a PostgreSQL user account that has the same name as the operating system user that started the server, and it also happens that that user always has permission to create databases. Instead of logging in as that user you can also specify the -U option everywhere to select a PostgreSQL user name to connect as.
5


Getting Started
mydb=#
That would mean you are a database superuser, which is most likely the case if you installed the PostgreSQL instance yourself. Being a superuser means that you are not subject to access controls. For the purposes of this tutorial that is not important.
If you encounter problems starting psql then go back to the previous section. The diagnostics of createdb and psql are similar, and if the former worked the latter should work as well.
The last line printed out by psql is the prompt, and it indicates that psql is listening to you and that you can type SQL queries into a work space maintained by psql. Try out these commands:
mydb=> SELECT version();
version ----------------------------------------------------------------------------------------PostgreSQL 16.2 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit (1 row)
mydb=> SELECT current_date; date -----------2016-01-07 (1 row)
mydb=> SELECT 2 + 2; ?column? ---------4 (1 row)
The psql program has a number of internal commands that are not SQL commands. They begin with the backslash character, “\”. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:
mydb=> \h
To get out of psql, type:
mydb=> \q
and psql will quit and return you to your command shell. (For more internal commands, type \? at the psql prompt.) The full capabilities of psql are documented in psql. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.
6


Chapter 2. The SQL Language
2.1. Introduction
This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including [melt93] and [date97]. You should be aware that some PostgreSQL language features are extensions to the standard.
In the examples that follow, we assume that you have created a database named mydb, as described in the previous chapter, and have been able to start psql.
Examples in this manual can also be found in the PostgreSQL source distribution in the directory src/tutorial/. (Binary distributions of PostgreSQL might not provide those files.) To use those files, first change to that directory and run make:
$ cd .../src/tutorial $ make
This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:
$ psql -s mydb
...
mydb=> \i basics.sql
The \i command reads in commands from the specified file. psql's -s option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file basics.sql.
2.2. Concepts
PostgreSQL is a relational database management system (RDBMS). That means it is a system for managing data stored in relations. Relation is essentially a mathematical term for table. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.
Each table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).
Tables are grouped into databases, and a collection of databases managed by a single PostgreSQL server instance constitutes a database cluster.
2.3. Creating a New Table
You can create a new table by specifying the table name, along with all column names and their types:
7


The SQL Language
CREATE TABLE weather ( city varchar(80), temp_lo int, -- low temperature temp_hi int, -- high temperature prcp real, -- precipitation date date );
You can enter this into psql with the line breaks. psql will recognize that the command is not terminated until the semicolon.
White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (“--”) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case-insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).
varchar(80) specifies a data type that can store arbitrary character strings up to 80 characters in length. int is the normal integer type. real is a type for storing single precision floating-point numbers. date should be self-explanatory. (Yes, the column of type date is also named date. This might be convenient or confusing — you choose.)
PostgreSQL supports the standard SQL types int, smallint, real, double precision, char(N), varchar(N), date, time, timestamp, and interval, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.
The second example will store cities and their associated geographical location:
CREATE TABLE cities ( name varchar(80), location point );
The point type is an example of a PostgreSQL-specific data type.
Finally, it should be mentioned that if you don't need a table any longer or want to recreate it differently you can remove it using the following command:
DROP TABLE tablename;
2.4. Populating a Table With Rows
The INSERT statement is used to populate a table with rows:
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes ('), as in the example. The date type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.
The point type requires a coordinate pair as input, as shown here:
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
8


The SQL Language
The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date) VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown:
INSERT INTO weather (date, city, temp_hi, temp_lo) VALUES ('1994-11-29', 'Hayward', 54, 37);
Many developers consider explicitly listing the columns better style than relying on the order implicitly.
Please enter all the commands shown above so you have some data to work with in the following sections.
You could also have used COPY to load large amounts of data from flat-text files. This is usually faster because the COPY command is optimized for this application while allowing less flexibility than INSERT. An example would be:
COPY weather FROM '/home/user/weather.txt';
where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the COPY command in COPY.
2.5. Querying a Table
To retrieve data from a table, the table is queried. An SQL SELECT statement is used to do this. The statement is divided into a select list (the part that lists the columns to be returned), a table list (the part that lists the tables from which to retrieve the data), and an optional qualification (the part that specifies any restrictions). For example, to retrieve all the rows of table weather, type:
SELECT * FROM weather;
Here * is a shorthand for “all columns”. 1 So the same result would be had with:
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
The output should be:
city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+-----------San Francisco | 46 | 50 | 0.25 | 1994-11-27 San Francisco | 43 | 57 | 0 | 1994-11-29 Hayward | 37 | 54 | | 1994-11-29 (3 rows)
You can write expressions, not just simple column references, in the select list. For example, you can do:
1 While SELECT * is useful for off-the-cuff queries, it is widely considered bad style in production code, since adding a column to the table would change the results.
9


The SQL Language
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
This should give:
city | temp_avg | date ---------------+----------+-----------San Francisco | 48 | 1994-11-27 San Francisco | 50 | 1994-11-29 Hayward | 45 | 1994-11-29 (3 rows)
Notice how the AS clause is used to relabel the output column. (The AS clause is optional.)
A query can be “qualified” by adding a WHERE clause that specifies which rows are wanted. The WHERE clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (AND, OR, and NOT) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:
SELECT * FROM weather WHERE city = 'San Francisco' AND prcp > 0.0;
Result:
city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+-----------San Francisco | 46 | 50 | 0.25 | 1994-11-27 (1 row)
You can request that the results of a query be returned in sorted order:
SELECT * FROM weather ORDER BY city;
city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+-----------Hayward | 37 | 54 | | 1994-11-29 San Francisco | 43 | 57 | 0 | 1994-11-29 San Francisco | 46 | 50 | 0.25 | 1994-11-27
In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:
SELECT * FROM weather ORDER BY city, temp_lo;
You can request that duplicate rows be removed from the result of a query:
SELECT DISTINCT city FROM weather;
city --------------
10


The SQL Language
Hayward San Francisco (2 rows)
Here again, the result row ordering might vary. You can ensure consistent results by using DISTINCT
and ORDER BY together: 2
SELECT DISTINCT city FROM weather ORDER BY city;
2.6. Joins Between Tables
Thus far, our queries have only accessed one table at a time. Queries can access multiple tables at once, or access the same table in such a way that multiple rows of the table are being processed at the same time. Queries that access multiple tables (or multiple instances of the same table) at one time are called join queries. They combine rows from one table with rows from a second table, with an expression specifying which rows are to be paired. For example, to return all the weather records together with the location of the associated city, the database needs to compare the city column of each row of the weather table with the name column of all rows in the cities table, and select the pairs of rows
where these values match.3 This would be accomplished by the following query:
SELECT * FROM weather JOIN cities ON city = name;
city | temp_lo | temp_hi | prcp | date | name | location ---------------+---------+---------+------+-----------+---------------+----------San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | (-194,53) San Francisco | 43 | 57 | 0 | 1994-11-29 | San Francisco | (-194,53) (2 rows)
Observe two things about the result set:
• There is no result row for the city of Hayward. This is because there is no matching entry in the cities table for Hayward, so the join ignores the unmatched rows in the weather table. We will see shortly how this can be fixed.
• There are two columns containing the city name. This is correct because the lists of columns from the weather and cities tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using *:
SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather JOIN cities ON city = name;
Since the columns all had different names, the parser automatically found which table they belong to. If there were duplicate column names in the two tables you'd need to qualify the column names to show which one you meant, as in:
2 In some database systems, including older versions of PostgreSQL, the implementation of DISTINCT automatically orders the rows and so ORDER BY is unnecessary. But this is not required by the SQL standard, and current PostgreSQL does not guarantee that DISTINCT causes the rows to be ordered.
3 This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.
11


The SQL Language
SELECT weather.city, weather.temp_lo, weather.temp_hi, weather.prcp, weather.date, cities.location FROM weather JOIN cities ON weather.city = cities.name;
It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.
Join queries of the kind seen thus far can also be written in this form:
SELECT * FROM weather, cities WHERE city = name;
This syntax pre-dates the JOIN/ON syntax, which was introduced in SQL-92. The tables are simply listed in the FROM clause, and the comparison expression is added to the WHERE clause. The results from this older implicit syntax and the newer explicit JOIN/ON syntax are identical. But for a reader of the query, the explicit syntax makes its meaning easier to understand: The join condition is introduced by its own key word whereas previously the condition was mixed into the WHERE clause together with other conditions.
Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the weather table and for each row to find the matching cities row(s). If no matching row is found we want some “empty values” to be substituted for the cities table's columns. This kind of query is called an outer join. (The joins we have seen so far are inner joins.) The command looks like this:
SELECT * FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
city | temp_lo | temp_hi | prcp | date | name | location ---------------+---------+---------+------+-----------+---------------+----------Hayward | 37 | 54 | | 1994-11-29 | |
San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | (-194,53) San Francisco | 43 | 57 | 0 | 1994-11-29 | San Francisco | (-194,53) (3 rows)
This query is called a left outer join because the table mentioned on the left of the join operator will have each of its rows in the output at least once, whereas the table on the right will only have those rows output that match some row of the left table. When outputting a left-table row for which there is no right-table match, empty (null) values are substituted for the right-table columns.
Exercise: There are also right outer joins and full outer joins. Try to find out what those do.
We can also join a table against itself. This is called a self join. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the temp_lo and temp_hi columns of each weather row to the temp_lo and temp_hi columns of all other weather rows. We can do this with the following query:
12


The SQL Language
SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high, w2.city, w2.temp_lo AS low, w2.temp_hi AS high FROM weather w1 JOIN weather w2 ON w1.temp_lo < w2.temp_lo AND w1.temp_hi > w2.temp_hi;
city | low | high | city | low | high ---------------+-----+------+---------------+-----+-----San Francisco | 43 | 57 | San Francisco | 46 | 50 Hayward | 37 | 54 | San Francisco | 46 | 50 (2 rows)
Here we have relabeled the weather table as w1 and w2 to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.:
SELECT * FROM weather w JOIN cities c ON w.city = c.name;
You will encounter this style of abbreviating quite frequently.
2.7. Aggregate Functions
Like most other relational database products, PostgreSQL supports aggregate functions. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the count, sum, avg (average), max (maximum) and min (minimum) over a set of rows.
As an example, we can find the highest low-temperature reading anywhere with:
SELECT max(temp_lo) FROM weather;
max ----46 (1 row)
If we wanted to know what city (or cities) that reading occurred in, we might try:
SELECT city FROM weather WHERE temp_lo = max(temp_lo); WRONG
but this will not work since the aggregate max cannot be used in the WHERE clause. (This restriction exists because the WHERE clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a subquery:
SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
city --------------San Francisco (1 row)
This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.
13


The SQL Language
Aggregates are also very useful in combination with GROUP BY clauses. For example, we can get the number of readings and the maximum low temperature observed in each city with:
SELECT city, count(*), max(temp_lo) FROM weather GROUP BY city;
city | count | max ---------------+-------+----Hayward | 1 | 37 San Francisco | 2 | 46 (2 rows)
which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using HAVING:
SELECT city, count(*), max(temp_lo) FROM weather GROUP BY city HAVING max(temp_lo) < 40;
city | count | max ---------+-------+----Hayward | 1 | 37 (1 row)
which gives us the same results for only the cities that have all temp_lo values below 40. Finally, if we only care about cities whose names begin with “S”, we might do:
SELECT city, count(*), max(temp_lo) FROM weather WHERE city LIKE 'S%' -- 1 GROUP BY city;
city | count | max ---------------+-------+----San Francisco | 2 | 46 (1 row)
1 The LIKE operator does pattern matching and is explained in Section 9.7.
It is important to understand the interaction between aggregates and SQL's WHERE and HAVING clauses. The fundamental difference between WHERE and HAVING is this: WHERE selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas HAVING selects group rows after groups and aggregates are computed. Thus, the WHERE clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the HAVING clause always contains aggregate functions. (Strictly speaking, you are allowed to write a HAVING clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the WHERE stage.)
In the previous example, we can apply the city name restriction in WHERE, since it needs no aggregate. This is more efficient than adding the restriction to HAVING, because we avoid doing the grouping and aggregate calculations for all rows that fail the WHERE check.
14


The SQL Language
Another way to select the rows that go into an aggregate computation is to use FILTER, which is a per-aggregate option:
SELECT city, count(*) FILTER (WHERE temp_lo < 45), max(temp_lo) FROM weather GROUP BY city;
city | count | max ---------------+-------+----Hayward | 1 | 37 San Francisco | 1 | 46 (2 rows)
FILTER is much like WHERE, except that it removes rows only from the input of the particular aggregate function that it is attached to. Here, the count aggregate counts only rows with temp_lo below 45; but the max aggregate is still applied to all rows, so it still finds the reading of 46.
2.8. Updates
You can update existing rows using the UPDATE command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows:
UPDATE weather SET temp_hi = temp_hi - 2, temp_lo = temp_lo - 2 WHERE date > '1994-11-28';
Look at the new state of the data:
SELECT * FROM weather;
city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+-----------San Francisco | 46 | 50 | 0.25 | 1994-11-27 San Francisco | 41 | 55 | 0 | 1994-11-29 Hayward | 35 | 52 | | 1994-11-29 (3 rows)
2.9. Deletions
Rows can be removed from a table using the DELETE command. Suppose you are no longer interested in the weather of Hayward. Then you can do the following to delete those rows from the table:
DELETE FROM weather WHERE city = 'Hayward';
All weather records belonging to Hayward are removed.
SELECT * FROM weather;
city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+-----------San Francisco | 46 | 50 | 0.25 | 1994-11-27
15


The SQL Language
San Francisco | 41 | 55 | 0 | 1994-11-29 (2 rows)
One should be wary of statements of the form
DELETE FROM tablename;
Without a qualification, DELETE will remove all rows from the given table, leaving it empty. The system will not request confirmation before doing this!
16


Chapter 3. Advanced Features
3.1. Introduction
In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.
This chapter will on occasion refer to examples found in Chapter 2 to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in advanced.sql in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to Section 2.1 for how to use the file.)
3.2. Views
Refer back to the queries in Section 2.6. Suppose the combined listing of weather records and city location is of particular interest to your application, but you do not want to type the query each time you need it. You can create a view over the query, which gives a name to the query that you can refer to like an ordinary table:
CREATE VIEW myview AS SELECT name, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name;
SELECT * FROM myview;
Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.
Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.
3.3. Foreign Keys
Recall the weather and cities tables from Chapter 2. Consider the following problem: You want to make sure that no one can insert rows in the weather table that do not have a matching entry in the cities table. This is called maintaining the referential integrity of your data. In simplistic database systems this would be implemented (if at all) by first looking at the cities table to check if a matching record exists, and then inserting or rejecting the new weather records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.
The new declaration of the tables would look like this:
CREATE TABLE cities ( name varchar(80) primary key, location point );
CREATE TABLE weather ( city varchar(80) references cities(name), temp_lo int,
17


Advanced Features
temp_hi int, prcp real, date date );
Now try inserting an invalid record:
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
ERROR: insert or update on table "weather" violates foreign key constraint "weather_city_fkey" DETAIL: Key (city)=(Berkeley) is not present in table "cities".
The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to Chapter 5 for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.
3.4. Transactions
Transactions are a fundamental concept of all database systems. The essential point of a transaction is that it bundles multiple steps into a single, all-or-nothing operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all.
For example, consider a bank database that contains balances for various customer accounts, as well as total deposit balances for branches. Suppose that we want to record a payment of $100.00 from Alice's account to Bob's account. Simplifying outrageously, the SQL commands for this might look like:
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; UPDATE branches SET balance = balance - 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice'); UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob'; UPDATE branches SET balance = balance + 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a transaction gives us this guarantee. A transaction is said to be atomic: from the point of view of other transactions, it either happens completely or not at all.
We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.
18


Advanced Features
Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.
In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with BEGIN and COMMIT commands. So our banking transaction would actually look like:
BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; -- etc etc COMMIT;
If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command ROLLBACK instead of COMMIT, and all our updates so far will be canceled.
PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a BEGIN command, then each individual statement has an implicit BEGIN and (if successful) COMMIT wrapped around it. A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block.
Note
Some client libraries issue BEGIN and COMMIT commands automatically, so that you might get the effect of transaction blocks without asking. Check the documentation for the interface you are using.
It's possible to control the statements in a transaction in a more granular fashion through the use of savepoints. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with SAVEPOINT, you can if needed roll back to the savepoint with ROLLBACK TO. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.
After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.
All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.
Remembering the bank database, suppose we debit $100.00 from Alice's account, and credit Bob's account, only to find later that we should have credited Wally's account. We could do it using savepoints like this:
BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; SAVEPOINT my_savepoint;
19


Advanced Features
UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob'; -- oops ... forget that and use Wally's account ROLLBACK TO my_savepoint; UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Wally'; COMMIT;
This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, ROLLBACK TO is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.
3.5. Window Functions
A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like nonwindow aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.
Here is an example that shows how to compare each employee's salary with the average salary in his or her department:
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
depname | empno | salary | avg -----------+-------+--------+----------------------develop | 11 | 5200 | 5020.0000000000000000 develop | 7 | 4200 | 5020.0000000000000000 develop | 9 | 4500 | 5020.0000000000000000 develop | 8 | 6000 | 5020.0000000000000000 develop | 10 | 5200 | 5020.0000000000000000 personnel | 5 | 3500 | 3700.0000000000000000 personnel | 2 | 3900 | 3700.0000000000000000 sales | 3 | 4800 | 4866.6666666666666667 sales | 1 | 5000 | 4866.6666666666666667 sales | 4 | 4800 | 4866.6666666666666667 (10 rows)
The first three output columns come directly from the table empsalary, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same depname value as the current row. (This actually is the same function as the non-window avg aggregate, but the OVER clause causes it to be treated as a window function and computed across the window frame.)
A window function call always contains an OVER clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or nonwindow aggregate. The OVER clause determines exactly how the rows of the query are split up for processing by the window function. The PARTITION BY clause within OVER divides the rows into groups, or partitions, that share the same values of the PARTITION BY expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.
You can also control the order in which rows are processed by window functions using ORDER BY within OVER. (The window ORDER BY does not even have to match the order in which the rows are output.) Here is an example:
20


Advanced Features
SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
depname | empno | salary | rank -----------+-------+--------+-----develop | 8 | 6000 | 1 develop | 10 | 5200 | 2 develop | 11 | 5200 | 2 develop | 9 | 4500 | 4 develop | 7 | 4200 | 5 personnel | 2 | 3900 | 1 personnel | 5 | 3500 | 2 sales | 1 | 5000 | 1 sales | 4 | 4800 | 2 sales | 3 | 4800 | 2 (10 rows)
As shown here, the rank function produces a numerical rank for each distinct ORDER BY value in the current row's partition, using the order defined by the ORDER BY clause. rank needs no explicit parameter, because its behavior is entirely determined by the OVER clause.
The rows considered by a window function are those of the “virtual table” produced by the query's FROM clause as filtered by its WHERE, GROUP BY, and HAVING clauses if any. For example, a row removed because it does not meet the WHERE condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different OVER clauses, but they all act on the same collection of rows defined by this virtual table.
We already saw that ORDER BY can be omitted if the ordering of rows is not important. It is also possible to omit PARTITION BY, in which case there is a single partition containing all rows.
There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its window frame. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if ORDER BY is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the ORDER BY clause. When ORDER BY is omitted the
default frame consists of all rows in the partition. 1 Here is an example using sum:
SELECT salary, sum(salary) OVER () FROM empsalary;
salary | sum --------+------5200 | 47100 5000 | 47100 3500 | 47100 4800 | 47100 3900 | 47100 4200 | 47100 4500 | 47100 4800 | 47100 6000 | 47100 5200 | 47100 (10 rows)
1 There are options to define the window frame in other ways, but this tutorial does not cover them. See Section 4.2.8 for details.
21


Advanced Features
Above, since there is no ORDER BY in the OVER clause, the window frame is the same as the partition, which for lack of PARTITION BY is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an ORDER BY clause, we get very different results:
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
salary | sum --------+------3500 | 3500 3900 | 7400 4200 | 11600 4500 | 16100 4800 | 25700 4800 | 25700 5000 | 30700 5200 | 41100 5200 | 41100 6000 | 47100 (10 rows)
Here the sum is taken from the first (lowest) salary up through the current one, including any duplicates of the current one (notice the results for the duplicated salaries).
Window functions are permitted only in the SELECT list and the ORDER BY clause of the query. They are forbidden elsewhere, such as in GROUP BY, HAVING and WHERE clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.
If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:
SELECT depname, empno, salary, enroll_date FROM (SELECT depname, empno, salary, enroll_date, rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos FROM empsalary ) AS ss WHERE pos < 3;
The above query only shows the rows from the inner query having rank less than 3.
When a query involves multiple window functions, it is possible to write out each one with a separate OVER clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a WINDOW clause and then referenced in OVER. For example:
SELECT sum(salary) OVER w, avg(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
More details about window functions can be found in Section 4.2.8, Section 9.22, Section 7.2.5, and the SELECT reference page.
22


Advanced Features
3.6. Inheritance
Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.
Let's create two tables: A table cities and a table capitals. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:
CREATE TABLE capitals ( name text, population real, elevation int, -- (in ft) state char(2) );
CREATE TABLE non_capitals ( name text, population real, elevation int -- (in ft) );
CREATE VIEW cities AS SELECT name, population, elevation FROM capitals UNION SELECT name, population, elevation FROM non_capitals;
This works OK as far as querying goes, but it gets ugly when you need to update several rows, for one thing.
A better solution is this:
CREATE TABLE cities ( name text, population real, elevation int -- (in ft) );
CREATE TABLE capitals ( state char(2) UNIQUE NOT NULL ) INHERITS (cities);
In this case, a row of capitals inherits all columns (name, population, and elevation) from its parent, cities. The type of the column name is text, a native PostgreSQL type for variable length character strings. The capitals table has an additional column, state, which shows its state abbreviation. In PostgreSQL, a table can inherit from zero or more other tables.
For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:
SELECT name, elevation FROM cities WHERE elevation > 500;
which returns:
23


Advanced Features
name | elevation -----------+----------Las Vegas | 2174 Mariposa | 1953 Madison | 845 (3 rows)
On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:
SELECT name, elevation FROM ONLY cities WHERE elevation > 500;
name | elevation -----------+----------Las Vegas | 2174 Mariposa | 1953 (2 rows)
Here the ONLY before cities indicates that the query should be run over only the cities table, and not tables below cities in the inheritance hierarchy. Many of the commands that we have already discussed — SELECT, UPDATE, and DELETE — support this ONLY notation.
Note
Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See Section 5.10 for more detail.
3.7. Conclusion
PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.
If you feel you need more introductory material, please visit the PostgreSQL web site2 for links to more resources.
2 https://www.postgresql.org
24


Part II. The SQL Language
This part describes the use of the SQL language in PostgreSQL. We start with describing the general syntax of SQL, then explain how to create the structures to hold data, how to populate the database, and how to query it. The middle part lists the available data types and functions for use in SQL commands. The rest treats several aspects that are important for tuning a database for optimal performance.
The information in this part is arranged so that a novice user can follow it start to end to gain a full understanding of the topics without having to refer forward too many times. The chapters are intended to be self-contained, so that advanced users can read the chapters individually as they choose. The information in this part is presented in a narrative fashion in topical units. Readers looking for a complete description of a particular command should see Part VI.
Readers of this part should know how to connect to a PostgreSQL database and issue SQL commands. Readers that are unfamiliar with these issues are encouraged to read Part I first. SQL commands are typically entered using the PostgreSQL interactive terminal psql, but other programs that have similar functionality can be used as well.


Table of Contents
4. SQL Syntax ............................................................................................................ 33 4.1. Lexical Structure ........................................................................................... 33 4.1.1. Identifiers and Key Words .................................................................... 33 4.1.2. Constants ........................................................................................... 35 4.1.3. Operators ........................................................................................... 40 4.1.4. Special Characters ............................................................................... 40 4.1.5. Comments ......................................................................................... 41 4.1.6. Operator Precedence ............................................................................ 41 4.2. Value Expressions ......................................................................................... 42 4.2.1. Column References ............................................................................. 43 4.2.2. Positional Parameters ........................................................................... 43 4.2.3. Subscripts .......................................................................................... 43 4.2.4. Field Selection .................................................................................... 44 4.2.5. Operator Invocations ........................................................................... 44 4.2.6. Function Calls .................................................................................... 45 4.2.7. Aggregate Expressions ......................................................................... 45 4.2.8. Window Function Calls ........................................................................ 47 4.2.9. Type Casts ......................................................................................... 50 4.2.10. Collation Expressions ......................................................................... 51 4.2.11. Scalar Subqueries .............................................................................. 52 4.2.12. Array Constructors ............................................................................ 52 4.2.13. Row Constructors .............................................................................. 53 4.2.14. Expression Evaluation Rules ............................................................... 55 4.3. Calling Functions .......................................................................................... 56 4.3.1. Using Positional Notation ..................................................................... 57 4.3.2. Using Named Notation ......................................................................... 57 4.3.3. Using Mixed Notation ......................................................................... 58 5. Data Definition ........................................................................................................ 59 5.1. Table Basics ................................................................................................. 59 5.2. Default Values .............................................................................................. 60 5.3. Generated Columns ........................................................................................ 61 5.4. Constraints ................................................................................................... 62 5.4.1. Check Constraints ............................................................................... 62 5.4.2. Not-Null Constraints ............................................................................ 65 5.4.3. Unique Constraints .............................................................................. 65 5.4.4. Primary Keys ..................................................................................... 67 5.4.5. Foreign Keys ...................................................................................... 68 5.4.6. Exclusion Constraints .......................................................................... 71 5.5. System Columns ........................................................................................... 71 5.6. Modifying Tables .......................................................................................... 72 5.6.1. Adding a Column ............................................................................... 73 5.6.2. Removing a Column ............................................................................ 73 5.6.3. Adding a Constraint ............................................................................ 73 5.6.4. Removing a Constraint ........................................................................ 74 5.6.5. Changing a Column's Default Value ....................................................... 74 5.6.6. Changing a Column's Data Type ............................................................ 74 5.6.7. Renaming a Column ............................................................................ 75 5.6.8. Renaming a Table ............................................................................... 75 5.7. Privileges ..................................................................................................... 75 5.8. Row Security Policies .................................................................................... 80 5.9. Schemas ....................................................................................................... 86 5.9.1. Creating a Schema .............................................................................. 86 5.9.2. The Public Schema ............................................................................. 87 5.9.3. The Schema Search Path ...................................................................... 87 5.9.4. Schemas and Privileges ........................................................................ 89
26


The SQL Language
5.9.5. The System Catalog Schema ................................................................. 89 5.9.6. Usage Patterns .................................................................................... 89 5.9.7. Portability .......................................................................................... 90 5.10. Inheritance .................................................................................................. 90 5.10.1. Caveats ............................................................................................ 93 5.11. Table Partitioning ........................................................................................ 94 5.11.1. Overview ......................................................................................... 94 5.11.2. Declarative Partitioning ...................................................................... 95 5.11.3. Partitioning Using Inheritance ............................................................ 100 5.11.4. Partition Pruning ............................................................................. 104 5.11.5. Partitioning and Constraint Exclusion .................................................. 106 5.11.6. Best Practices for Declarative Partitioning ............................................ 107 5.12. Foreign Data ............................................................................................. 108 5.13. Other Database Objects ............................................................................... 108 5.14. Dependency Tracking ................................................................................. 108 6. Data Manipulation .................................................................................................. 111 6.1. Inserting Data ............................................................................................. 111 6.2. Updating Data ............................................................................................. 112 6.3. Deleting Data .............................................................................................. 113 6.4. Returning Data from Modified Rows ............................................................... 113 7. Queries ................................................................................................................. 115 7.1. Overview .................................................................................................... 115 7.2. Table Expressions ........................................................................................ 115 7.2.1. The FROM Clause .............................................................................. 116 7.2.2. The WHERE Clause ............................................................................ 124 7.2.3. The GROUP BY and HAVING Clauses .................................................. 125 7.2.4. GROUPING SETS, CUBE, and ROLLUP .............................................. 128 7.2.5. Window Function Processing .............................................................. 131 7.3. Select Lists ................................................................................................. 131 7.3.1. Select-List Items ............................................................................... 131 7.3.2. Column Labels .................................................................................. 132 7.3.3. DISTINCT ...................................................................................... 132 7.4. Combining Queries (UNION, INTERSECT, EXCEPT) ........................................ 133 7.5. Sorting Rows (ORDER BY) .......................................................................... 134 7.6. LIMIT and OFFSET .................................................................................... 135 7.7. VALUES Lists ............................................................................................. 135 7.8. WITH Queries (Common Table Expressions) .................................................... 136 7.8.1. SELECT in WITH ............................................................................. 137 7.8.2. Recursive Queries ............................................................................. 137 7.8.3. Common Table Expression Materialization ............................................ 142 7.8.4. Data-Modifying Statements in WITH .................................................... 143 8. Data Types ............................................................................................................ 146 8.1. Numeric Types ............................................................................................ 147 8.1.1. Integer Types .................................................................................... 148 8.1.2. Arbitrary Precision Numbers ............................................................... 148 8.1.3. Floating-Point Types .......................................................................... 150 8.1.4. Serial Types ..................................................................................... 152 8.2. Monetary Types ........................................................................................... 153 8.3. Character Types ........................................................................................... 153 8.4. Binary Data Types ....................................................................................... 156 8.4.1. bytea Hex Format ........................................................................... 156 8.4.2. bytea Escape Format ....................................................................... 156 8.5. Date/Time Types ......................................................................................... 158 8.5.1. Date/Time Input ................................................................................ 159 8.5.2. Date/Time Output .............................................................................. 163 8.5.3. Time Zones ...................................................................................... 164 8.5.4. Interval Input .................................................................................... 165 8.5.5. Interval Output .................................................................................. 167
27


The SQL Language
8.6. Boolean Type .............................................................................................. 167 8.7. Enumerated Types ....................................................................................... 168 8.7.1. Declaration of Enumerated Types ......................................................... 168 8.7.2. Ordering .......................................................................................... 169 8.7.3. Type Safety ...................................................................................... 169 8.7.4. Implementation Details ....................................................................... 170 8.8. Geometric Types ......................................................................................... 170 8.8.1. Points .............................................................................................. 171 8.8.2. Lines ............................................................................................... 171 8.8.3. Line Segments .................................................................................. 171 8.8.4. Boxes .............................................................................................. 171 8.8.5. Paths ............................................................................................... 172 8.8.6. Polygons .......................................................................................... 172 8.8.7. Circles ............................................................................................. 172 8.9. Network Address Types ................................................................................ 173 8.9.1. inet .............................................................................................. 173 8.9.2. cidr .............................................................................................. 173 8.9.3. inet vs. cidr ................................................................................ 174 8.9.4. macaddr ........................................................................................ 174 8.9.5. macaddr8 ...................................................................................... 174 8.10. Bit String Types ........................................................................................ 175 8.11. Text Search Types ...................................................................................... 176 8.11.1. tsvector ..................................................................................... 176 8.11.2. tsquery ....................................................................................... 177 8.12. UUID Type ............................................................................................... 179 8.13. XML Type ................................................................................................ 179 8.13.1. Creating XML Values ...................................................................... 179 8.13.2. Encoding Handling .......................................................................... 180 8.13.3. Accessing XML Values .................................................................... 181 8.14. JSON Types .............................................................................................. 181 8.14.1. JSON Input and Output Syntax .......................................................... 183 8.14.2. Designing JSON Documents .............................................................. 184 8.14.3. jsonb Containment and Existence ..................................................... 184 8.14.4. jsonb Indexing .............................................................................. 186 8.14.5. jsonb Subscripting ......................................................................... 188 8.14.6. Transforms ..................................................................................... 190 8.14.7. jsonpath Type ................................................................................. 190 8.15. Arrays ...................................................................................................... 191 8.15.1. Declaration of Array Types ............................................................... 192 8.15.2. Array Value Input ............................................................................ 192 8.15.3. Accessing Arrays ............................................................................. 194 8.15.4. Modifying Arrays ............................................................................ 196 8.15.5. Searching in Arrays ......................................................................... 199 8.15.6. Array Input and Output Syntax .......................................................... 200 8.16. Composite Types ....................................................................................... 201 8.16.1. Declaration of Composite Types ......................................................... 201 8.16.2. Constructing Composite Values .......................................................... 202 8.16.3. Accessing Composite Types .............................................................. 203 8.16.4. Modifying Composite Types .............................................................. 203 8.16.5. Using Composite Types in Queries ..................................................... 204 8.16.6. Composite Type Input and Output Syntax ............................................ 206 8.17. Range Types ............................................................................................. 207 8.17.1. Built-in Range and Multirange Types .................................................. 208 8.17.2. Examples ....................................................................................... 208 8.17.3. Inclusive and Exclusive Bounds ......................................................... 208 8.17.4. Infinite (Unbounded) Ranges ............................................................. 209 8.17.5. Range Input/Output .......................................................................... 209 8.17.6. Constructing Ranges and Multiranges .................................................. 210
28


The SQL Language
8.17.7. Discrete Range Types ....................................................................... 211 8.17.8. Defining New Range Types ............................................................... 211 8.17.9. Indexing ......................................................................................... 212 8.17.10. Constraints on Ranges .................................................................... 212 8.18. Domain Types ........................................................................................... 213 8.19. Object Identifier Types ............................................................................... 214 8.20. pg_lsn Type ........................................................................................... 216 8.21. Pseudo-Types ............................................................................................ 217 9. Functions and Operators .......................................................................................... 219 9.1. Logical Operators ........................................................................................ 219 9.2. Comparison Functions and Operators .............................................................. 220 9.3. Mathematical Functions and Operators ............................................................ 224 9.4. String Functions and Operators ...................................................................... 231 9.4.1. format .......................................................................................... 239 9.5. Binary String Functions and Operators ............................................................ 241 9.6. Bit String Functions and Operators ................................................................. 245 9.7. Pattern Matching ......................................................................................... 247 9.7.1. LIKE .............................................................................................. 248 9.7.2. SIMILAR TO Regular Expressions ..................................................... 249 9.7.3. POSIX Regular Expressions ................................................................ 250 9.8. Data Type Formatting Functions ..................................................................... 266 9.9. Date/Time Functions and Operators ................................................................ 274 9.9.1. EXTRACT, date_part .................................................................... 281 9.9.2. date_trunc .................................................................................. 285 9.9.3. date_bin ...................................................................................... 286 9.9.4. AT TIME ZONE ............................................................................. 287 9.9.5. Current Date/Time ............................................................................. 288 9.9.6. Delaying Execution ........................................................................... 289 9.10. Enum Support Functions ............................................................................. 290 9.11. Geometric Functions and Operators ............................................................... 291 9.12. Network Address Functions and Operators ..................................................... 298 9.13. Text Search Functions and Operators ............................................................. 301 9.14. UUID Functions ........................................................................................ 308 9.15. XML Functions ......................................................................................... 308 9.15.1. Producing XML Content ................................................................... 308 9.15.2. XML Predicates .............................................................................. 312 9.15.3. Processing XML .............................................................................. 314 9.15.4. Mapping Tables to XML .................................................................. 319 9.16. JSON Functions and Operators ..................................................................... 322 9.16.1. Processing and Creating JSON Data .................................................... 323 9.16.2. The SQL/JSON Path Language .......................................................... 334 9.17. Sequence Manipulation Functions ................................................................. 342 9.18. Conditional Expressions .............................................................................. 343 9.18.1. CASE ............................................................................................. 344 9.18.2. COALESCE ..................................................................................... 345 9.18.3. NULLIF ......................................................................................... 345 9.18.4. GREATEST and LEAST .................................................................... 346 9.19. Array Functions and Operators ..................................................................... 346 9.20. Range/Multirange Functions and Operators ..................................................... 350 9.21. Aggregate Functions ................................................................................... 356 9.22. Window Functions ..................................................................................... 363 9.23. Subquery Expressions ................................................................................. 365 9.23.1. EXISTS ......................................................................................... 365 9.23.2. IN ................................................................................................. 365 9.23.3. NOT IN ........................................................................................ 366 9.23.4. ANY/SOME ...................................................................................... 366 9.23.5. ALL ............................................................................................... 367 9.23.6. Single-Row Comparison ................................................................... 367
29


The SQL Language
9.24. Row and Array Comparisons ....................................................................... 367 9.24.1. IN ................................................................................................. 368 9.24.2. NOT IN ........................................................................................ 368 9.24.3. ANY/SOME (array) ............................................................................ 368 9.24.4. ALL (array) .................................................................................... 369 9.24.5. Row Constructor Comparison ............................................................ 369 9.24.6. Composite Type Comparison ............................................................. 370 9.25. Set Returning Functions .............................................................................. 370 9.26. System Information Functions and Operators .................................................. 374 9.26.1. Session Information Functions ........................................................... 374 9.26.2. Access Privilege Inquiry Functions ..................................................... 377 9.26.3. Schema Visibility Inquiry Functions .................................................... 380 9.26.4. System Catalog Information Functions ................................................ 381 9.26.5. Object Information and Addressing Functions ....................................... 387 9.26.6. Comment Information Functions ........................................................ 388 9.26.7. Data Validity Checking Functions ...................................................... 388 9.26.8. Transaction ID and Snapshot Information Functions ............................... 389 9.26.9. Committed Transaction Information Functions ...................................... 391 9.26.10. Control Data Functions ................................................................... 392 9.27. System Administration Functions .................................................................. 393 9.27.1. Configuration Settings Functions ........................................................ 393 9.27.2. Server Signaling Functions ................................................................ 394 9.27.3. Backup Control Functions ................................................................. 396 9.27.4. Recovery Control Functions .............................................................. 398 9.27.5. Snapshot Synchronization Functions ................................................... 400 9.27.6. Replication Management Functions ..................................................... 400 9.27.7. Database Object Management Functions .............................................. 403 9.27.8. Index Maintenance Functions ............................................................. 406 9.27.9. Generic File Access Functions ........................................................... 406 9.27.10. Advisory Lock Functions ................................................................ 409 9.28. Trigger Functions ....................................................................................... 410 9.29. Event Trigger Functions .............................................................................. 411 9.29.1. Capturing Changes at Command End .................................................. 411 9.29.2. Processing Objects Dropped by a DDL Command ................................. 412 9.29.3. Handling a Table Rewrite Event ......................................................... 413 9.30. Statistics Information Functions .................................................................... 414 9.30.1. Inspecting MCV Lists ...................................................................... 414 10. Type Conversion .................................................................................................. 416 10.1. Overview .................................................................................................. 416 10.2. Operators .................................................................................................. 417 10.3. Functions .................................................................................................. 421 10.4. Value Storage ............................................................................................ 425 10.5. UNION, CASE, and Related Constructs .......................................................... 426 10.6. SELECT Output Columns ............................................................................ 427 11. Indexes ............................................................................................................... 429 11.1. Introduction ............................................................................................... 429 11.2. Index Types .............................................................................................. 430 11.2.1. B-Tree ........................................................................................... 430 11.2.2. Hash .............................................................................................. 431 11.2.3. GiST ............................................................................................. 431 11.2.4. SP-GiST ......................................................................................... 431 11.2.5. GIN ............................................................................................... 431 11.2.6. BRIN ............................................................................................. 432 11.3. Multicolumn Indexes .................................................................................. 432 11.4. Indexes and ORDER BY ............................................................................. 433 11.5. Combining Multiple Indexes ........................................................................ 434 11.6. Unique Indexes .......................................................................................... 435 11.7. Indexes on Expressions ............................................................................... 435
30


The SQL Language
11.8. Partial Indexes ........................................................................................... 436 11.9. Index-Only Scans and Covering Indexes ........................................................ 439 11.10. Operator Classes and Operator Families ....................................................... 441 11.11. Indexes and Collations .............................................................................. 443 11.12. Examining Index Usage ............................................................................. 443 12. Full Text Search ................................................................................................... 445 12.1. Introduction ............................................................................................... 445 12.1.1. What Is a Document? ....................................................................... 446 12.1.2. Basic Text Matching ........................................................................ 446 12.1.3. Configurations ................................................................................. 448 12.2. Tables and Indexes ..................................................................................... 449 12.2.1. Searching a Table ............................................................................ 449 12.2.2. Creating Indexes .............................................................................. 450 12.3. Controlling Text Search .............................................................................. 451 12.3.1. Parsing Documents .......................................................................... 451 12.3.2. Parsing Queries ............................................................................... 452 12.3.3. Ranking Search Results .................................................................... 455 12.3.4. Highlighting Results ......................................................................... 457 12.4. Additional Features .................................................................................... 458 12.4.1. Manipulating Documents .................................................................. 458 12.4.2. Manipulating Queries ....................................................................... 459 12.4.3. Triggers for Automatic Updates ......................................................... 462 12.4.4. Gathering Document Statistics ........................................................... 463 12.5. Parsers ..................................................................................................... 464 12.6. Dictionaries ............................................................................................... 465 12.6.1. Stop Words .................................................................................... 466 12.6.2. Simple Dictionary ............................................................................ 467 12.6.3. Synonym Dictionary ........................................................................ 468 12.6.4. Thesaurus Dictionary ........................................................................ 470 12.6.5. Ispell Dictionary .............................................................................. 472 12.6.6. Snowball Dictionary ......................................................................... 474 12.7. Configuration Example ............................................................................... 475 12.8. Testing and Debugging Text Search .............................................................. 476 12.8.1. Configuration Testing ....................................................................... 476 12.8.2. Parser Testing ................................................................................. 479 12.8.3. Dictionary Testing ........................................................................... 480 12.9. Preferred Index Types for Text Search ........................................................... 481 12.10. psql Support ............................................................................................ 482 12.11. Limitations .............................................................................................. 485 13. Concurrency Control ............................................................................................. 486 13.1. Introduction ............................................................................................... 486 13.2. Transaction Isolation ................................................................................... 486 13.2.1. Read Committed Isolation Level ........................................................ 487 13.2.2. Repeatable Read Isolation Level ......................................................... 489 13.2.3. Serializable Isolation Level ................................................................ 490 13.3. Explicit Locking ........................................................................................ 492 13.3.1. Table-Level Locks ........................................................................... 492 13.3.2. Row-Level Locks ............................................................................ 495 13.3.3. Page-Level Locks ............................................................................ 496 13.3.4. Deadlocks ....................................................................................... 496 13.3.5. Advisory Locks ............................................................................... 497 13.4. Data Consistency Checks at the Application Level ........................................... 498 13.4.1. Enforcing Consistency with Serializable Transactions ............................. 498 13.4.2. Enforcing Consistency with Explicit Blocking Locks .............................. 499 13.5. Serialization Failure Handling ...................................................................... 499 13.6. Caveats ..................................................................................................... 500 13.7. Locking and Indexes ................................................................................... 500 14. Performance Tips ................................................................................................. 502
31


The SQL Language
14.1. Using EXPLAIN ........................................................................................ 502 14.1.1. EXPLAIN Basics ............................................................................. 502 14.1.2. EXPLAIN ANALYZE ...................................................................... 508 14.1.3. Caveats .......................................................................................... 513 14.2. Statistics Used by the Planner ...................................................................... 514 14.2.1. Single-Column Statistics ................................................................... 514 14.2.2. Extended Statistics ........................................................................... 516 14.3. Controlling the Planner with Explicit JOIN Clauses ......................................... 519 14.4. Populating a Database ................................................................................. 521 14.4.1. Disable Autocommit ........................................................................ 521 14.4.2. Use COPY ...................................................................................... 521 14.4.3. Remove Indexes .............................................................................. 522 14.4.4. Remove Foreign Key Constraints ....................................................... 522 14.4.5. Increase maintenance_work_mem ................................................. 522 14.4.6. Increase max_wal_size ................................................................ 522 14.4.7. Disable WAL Archival and Streaming Replication ................................. 522 14.4.8. Run ANALYZE Afterwards ................................................................ 523 14.4.9. Some Notes about pg_dump .............................................................. 523 14.5. Non-Durable Settings .................................................................................. 524 15. Parallel Query ...................................................................................................... 525 15.1. How Parallel Query Works .......................................................................... 525 15.2. When Can Parallel Query Be Used? .............................................................. 526 15.3. Parallel Plans ............................................................................................. 527 15.3.1. Parallel Scans .................................................................................. 527 15.3.2. Parallel Joins .................................................................................. 527 15.3.3. Parallel Aggregation ......................................................................... 528 15.3.4. Parallel Append ............................................................................... 528 15.3.5. Parallel Plan Tips ............................................................................ 528 15.4. Parallel Safety ........................................................................................... 529 15.4.1. Parallel Labeling for Functions and Aggregates ..................................... 529
32


Chapter 4. SQL Syntax
This chapter describes the syntax of SQL. It forms the foundation for understanding the following chapters which will go into detail about how SQL commands are applied to define and modify data.
We also advise users who are already familiar with SQL to read this chapter carefully because it contains several rules and concepts that are implemented inconsistently among SQL databases or that are specific to PostgreSQL.
4.1. Lexical Structure
SQL input consists of a sequence of commands. A command is composed of a sequence of tokens, terminated by a semicolon (“;”). The end of the input stream also terminates a command. Which tokens are valid depends on the syntax of the particular command.
A token can be a key word, an identifier, a quoted identifier, a literal (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).
For example, the following is (syntactically) valid SQL input:
SELECT * FROM MY_TABLE; UPDATE MY_TABLE SET A = 5; INSERT INTO MY_TABLE VALUES (3, 'hi there');
This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).
Additionally, comments can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.
The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a “SELECT”, an “UPDATE”, and an “INSERT” command. But for instance the UPDATE command always requires a SET token to appear in a certain position, and this particular variation of INSERT also requires a VALUES in order to be complete. The precise syntax rules for each command are described in Part VI.
4.1.1. Identifiers and Key Words
Tokens such as SELECT, UPDATE, or VALUES in the example above are examples of key words, that is, words that have a fixed meaning in the SQL language. The tokens MY_TABLE and A are examples of identifiers. They identify names of tables, columns, or other database objects, depending on the command they are used in. Therefore they are sometimes simply called “names”. Key words and identifiers have the same lexical structure, meaning that one cannot know whether a token is an identifier or a key word without knowing the language. A complete list of key words can be found in Appendix C.
SQL identifiers and key words must begin with a letter (a-z, but also letters with diacritical marks and non-Latin letters) or an underscore (_). Subsequent characters in an identifier or key word can be letters, underscores, digits (0-9), or dollar signs ($). Note that dollar signs are not allowed in identifiers according to the letter of the SQL standard, so their use might render applications less portable. The SQL standard will not define a key word that contains digits or starts or ends with an underscore, so identifiers of this form are safe against possible conflict with future extensions of the standard.
33


SQL Syntax
The system uses no more than NAMEDATALEN-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, NAMEDATALEN is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the NAMEDATALEN constant in src/include/pg_config_manual.h.
Key words and unquoted identifiers are case-insensitive. Therefore:
UPDATE MY_TABLE SET A = 5;
can equivalently be written as:
uPDaTE my_TabLE SeT a = 5;
A convention often used is to write key words in upper case and names in lower case, e.g.:
UPDATE my_table SET a = 5;
There is a second kind of identifier: the delimited identifier or quoted identifier. It is formed by enclosing an arbitrary sequence of characters in double-quotes ("). A delimited identifier is always an identifier, never a key word. So "select" could be used to refer to a column or table named “select”, whereas an unquoted select would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:
UPDATE "my_table" SET "a" = 5;
Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.
Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers FOO, foo, and "foo" are considered the same by PostgreSQL, but "Foo" and "FOO" are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, foo should be equivalent to "FOO" not "foo" according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)
A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with U& (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example U&"foo". (Note that this creates an ambiguity with the operator &. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier "data" could be written as
U&"d\0061t\+000061"
The following less trivial example writes the Russian word “slon” (elephant) in Cyrillic letters:
U&"\0441\043B\043E\043D"
If a different escape character than backslash is desired, it can be specified using the UESCAPE clause after the string, for example:
34


SQL Syntax
U&"d!0061t!+000061" UESCAPE '!'
The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes, after UESCAPE.
To include the escape character in the identifier literally, write it twice.
Either the 4-digit or the 6-digit escape form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but are combined into a single code point.)
If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.
4.1.2. Constants
There are three kinds of implicitly-typed constants in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.
4.1.2.1. String Constants
A string constant in SQL is an arbitrary sequence of characters bounded by single quotes ('), for example 'This is a string'. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., 'Dianne''s horse'. Note that this is not the same as a double-quote character (").
Two string constants that are only separated by whitespace with at least one newline are concatenated and effectively treated as if the string had been written as one constant. For example:
SELECT 'foo' 'bar';
is equivalent to:
SELECT 'foobar';
but:
SELECT 'foo' 'bar';
is not valid syntax. (This slightly bizarre behavior is specified by SQL; PostgreSQL is following the standard.)
4.1.2.2. String Constants with C-Style Escapes
PostgreSQL also accepts “escape” string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter E (upper or lower case) just before the opening single quote, e.g., E'foo'. (When continuing an escape string constant across lines, write E only before the first opening quote.) Within an escape string, a backslash character (\) begins a C-like backslash escape sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in Table 4.1.
35


SQL Syntax
Table 4.1. Backslash Escape Sequences
Backslash Escape Sequence Interpretation
\b backspace
\f form feed
\n newline
\r carriage return
\t tab
\o, \oo, \ooo (o = 0–7) octal byte value
\xh, \xhh (h = 0–9, A–F) hexadecimal byte value
\uxxxx, \Uxxxxxxxx (x = 0–9, A–F) 16 or 32-bit hexadecimal Unicode character value
Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (\\). Also, a single quote can be included in an escape string by writing \', in addition to the normal way of ''.
It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in Section 4.1.2.3; then the server will check that the character conversion is possible.
Caution
If the configuration parameter standard_conforming_strings is off, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is on, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to off, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an E.
In addition to standard_conforming_strings, the configuration parameters escape_string_warning and backslash_quote govern treatment of backslashes in string constants.
The character with the code zero cannot be in a string constant.
4.1.2.3. String Constants with Unicode Escapes
PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with U& (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example U&'foo'. (Note that this creates an ambiguity with the operator &. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string 'data' could be written as
U&'d\0061t\+000061'
The following less trivial example writes the Russian word “slon” (elephant) in Cyrillic letters:
36


SQL Syntax
U&'\0441\043B\043E\043D'
If a different escape character than backslash is desired, it can be specified using the UESCAPE clause after the string, for example:
U&'d!0061t!+000061' UESCAPE '!'
The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.
To include the escape character in the string literally, write it twice.
Either the 4-digit or the 6-digit escape form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but are combined into a single code point.)
If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.
Also, the Unicode escape syntax for string constants only works when the configuration parameter standard_conforming_strings is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.
4.1.2.4. Dollar-Quoted String Constants
While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called “dollar quoting”, to write string constants. A dollar-quoted string constant consists of a dollar sign ($), an optional “tag” of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string “Dianne's horse” using dollar quoting:
$$Dianne's horse$$ $SomeTag$Dianne's horse$SomeTag$
Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.
It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:
$function$ BEGIN RETURN ($1 ~ $q$[\t\r\n\v\\]$q$); END; $function$
Here, the sequence $q$[\t\r\n\v\\]$q$ represents a dollar-quoted literal string [\t\r\n\v \\], which will be recognized when the function body is executed by PostgreSQL. But since the sequence does not match the outer dollar quoting delimiter $function$, it is just some more characters within the constant so far as the outer string is concerned.
37


SQL Syntax
The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so $tag$String content$tag$ is correct, but $TAG$String content$tag$ is not.
A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier.
Dollar quoting is not part of the SQL standard, but it is often a more convenient way to write complicated string literals than the standard-compliant single quote syntax. It is particularly useful when representing string constants inside other constants, as is often needed in procedural function definitions. With single-quote syntax, each backslash in the above example would have to be written as four backslashes, which would be reduced to two backslashes in parsing the original string constant, and then to one when the inner string constant is re-parsed during function execution.
4.1.2.5. Bit-String Constants
Bit-string constants look like regular string constants with a B (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., B'1001'. The only characters allowed within bit-string constants are 0 and 1.
Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading X (upper or lower case), e.g., X'1FF'. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.
Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.
4.1.2.6. Numeric Constants
Numeric constants are accepted in these general forms:
digits digits.[digits][e[+-]digits] [digits].digits[e[+-]digits] digitse[+-]digits
where digits is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (e), if one is present. There cannot be any spaces or other characters embedded in the constant, except for underscores, which can be used for visual grouping as described below. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant.
These are some examples of valid numeric constants:
42 3.5 4. .001 5e2 1.925e-3
Additionally, non-decimal integer constants are accepted in these forms:
0xhexdigits 0ooctdigits 0bbindigits
38


SQL Syntax
where hexdigits is one or more hexadecimal digits (0-9, A-F), octdigits is one or more octal digits (0-7), and bindigits is one or more binary digits (0 or 1). Hexadecimal digits and the radix prefixes can be in upper or lower case. Note that only integers can have non-decimal forms, not numbers with fractional parts.
These are some examples of valid non-decimal integer constants:
0b100101 0B10011001 0o273 0O755 0x42f 0XFFFF
For visual grouping, underscores can be inserted between digits. These have no further effect on the value of the constant. For example:
1_500_000_000 0b10001000_00000000 0o_1_755 0xFFFF_FFFF 1.618_034
Underscores are not allowed at the start or end of a numeric constant or a group of digits (that is, immediately before or after the decimal point or the exponent marker), and more than one underscore in a row is not allowed.
A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type integer if its value fits in type integer (32 bits); otherwise it is presumed to be type bigint if its value fits in type bigint (64 bits); otherwise it is taken to be type numeric. Constants that contain decimal points and/or exponents are always initially presumed to be type numeric.
The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type real (float4) by writing:
REAL '1.23' -- string style 1.23::REAL -- PostgreSQL (historical) style
These are actually just special cases of the general casting notations discussed next.
4.1.2.7. Constants of Other Types
A constant of an arbitrary type can be entered using any one of the following notations:
type 'string' 'string'::type CAST ( 'string' AS type )
The string constant's text is passed to the input conversion routine for the type called type. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.
The string constant can be written using either regular SQL notation or dollar-quoting.
39


SQL Syntax
It is also possible to specify a type coercion using a function-like syntax:
typename ( 'string' )
but not all type names can be used in this way; see Section 4.2.9 for details.
The ::, CAST(), and function-call syntaxes can also be used to specify run-time type conversions of arbitrary expressions, as discussed in Section 4.2.9. To avoid syntactic ambiguity, the type 'string' syntax can only be used to specify the type of a simple literal constant. Another restriction on the type 'string' syntax is that it does not work for array types; use :: or CAST() to specify the type of an array constant.
The CAST() syntax conforms to SQL. The type 'string' syntax is a generalization of the standard: SQL specifies this syntax only for a few data types, but PostgreSQL allows it for all types. The syntax with :: is historical PostgreSQL usage, as is the function-call syntax.
4.1.3. Operators
An operator name is a sequence of up to NAMEDATALEN-1 (63 by default) characters from the following list:
+-*/<>=~!@#%^&|`?
There are a few restrictions on operator names, however:
• -- and /* cannot appear anywhere in an operator name, since they will be taken as the start of a comment.
• A multiple-character operator name cannot end in + or -, unless the name also contains at least one of these characters:
~!@#%^&|`?
For example, @- is an allowed operator name, but *- is not. This restriction allows PostgreSQL to parse SQL-compliant queries without requiring spaces between tokens.
When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a prefix operator named @, you cannot write X*@Y; you must write X* @Y to ensure that PostgreSQL reads it as two operator names not one.
4.1.4. Special Characters
Some characters that are not alphanumeric have a special meaning that is different from being an operator. Details on the usage can be found at the location where the respective syntax element is described. This section only exists to advise the existence and summarize the purposes of these characters.
• A dollar sign ($) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant.
• Parentheses (()) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.
• Brackets ([]) are used to select the elements of an array. See Section 8.15 for more information on arrays.
• Commas (,) are used in some syntactical constructs to separate the elements of a list.
40


SQL Syntax
• The semicolon (;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.
• The colon (:) is used to select “slices” from arrays. (See Section 8.15.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.
• The asterisk (*) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.
• The period (.) is used in numeric constants, and to separate schema, table, and column names.
4.1.5. Comments
A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.:
-- This is a standard SQL comment
Alternatively, C-style block comments can be used:
/* multiline comment * with nesting: /* nested block comment */ */
where the comment begins with /* and extends to the matching occurrence of */. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments.
A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.
4.1.6. Operator Precedence
Table 4.2 shows the precedence and associativity of the operators in PostgreSQL. Most operators have the same precedence and are left-associative. The precedence and associativity of the operators is hardwired into the parser. Add parentheses if you want an expression with multiple operators to be parsed in some other way than what the precedence rules imply.
Table 4.2. Operator Precedence (highest to lowest)
Operator/Element Associativity Description
. left table/column name separator
:: left PostgreSQL-style typecast
[ ] left array element selection
+ - right unary plus, unary minus
COLLATE left collation selection
AT left AT TIME ZONE
^ left exponentiation
* / % left multiplication, division, modulo
+ - left addition, subtraction
(any other operator) left all other native and user-defined operators
41


SQL Syntax
Operator/Element Associativity Description
BETWEEN IN LIKE ILIKE SIMILAR
range containment, set membership, string matching
< > = <= >= <> comparison operators
IS ISNULL NOTNULL IS TRUE, IS FALSE, IS NULL, IS DISTINCT FROM, etc.
NOT right logical negation
AND left logical conjunction
OR left logical disjunction
Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a “+” operator for some custom data type it will have the same precedence as the built-in “+” operator, no matter what yours does.
When a schema-qualified operator name is used in the OPERATOR syntax, as for example in:
SELECT 3 OPERATOR(pg_catalog.+) 4;
the OPERATOR construct is taken to have the default precedence shown in Table 4.2 for “any other operator”. This is true no matter which specific operator appears inside OPERATOR().
Note
PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, <= >= and <> used to be treated as generic operators; IS tests used to have higher priority; and NOT BETWEEN and related constructs acted inconsistently, being taken in some cases as having the precedence of NOT rather than BETWEEN. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in “no such operator” failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported.
4.2. Value Expressions
Value expressions are used in a variety of contexts, such as in the target list of the SELECT command, as new column values in INSERT or UPDATE, or in search conditions in a number of commands. The result of a value expression is sometimes called a scalar, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called scalar expressions (or even simply expressions). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.
A value expression is one of the following:
• A constant or literal value
• A column reference
• A positional parameter reference, in the body of a function definition or prepared statement
• A subscripted expression
• A field selection expression
42


SQL Syntax
• An operator invocation
• A function call
• An aggregate expression
• A window function call
• A type cast
• A collation expression
• A scalar subquery
• An array constructor
• A row constructor
• Another value expression in parentheses (used to group subexpressions and override precedence)
In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in Chapter 9. An example is the IS NULL clause.
We have already discussed constants in Section 4.1.2. The following sections discuss the remaining options.
4.2.1. Column References
A column can be referenced in the form:
correlation.columnname
correlation is the name of a table (possibly qualified with a schema name), or an alias for a table defined by means of a FROM clause. The correlation name and separating dot can be omitted if the column name is unique across all the tables being used in the current query. (See also Chapter 7.)
4.2.2. Positional Parameters
A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:
$number
For example, consider the definition of a function, dept, as:
CREATE FUNCTION dept(text) RETURNS dept AS $$ SELECT * FROM dept WHERE name = $1 $$ LANGUAGE SQL;
Here the $1 references the value of the first function argument whenever the function is invoked.
4.2.3. Subscripts
If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing
43


SQL Syntax
expression[subscript]
or multiple adjacent elements (an “array slice”) can be extracted by writing
expression[lower_subscript:upper_subscript]
(Here, the brackets [ ] are meant to appear literally.) Each subscript is itself an expression, which will be rounded to the nearest integer value.
In general the array expression must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:
mytable.arraycolumn[4] mytable.two_d_column[17][34] $1[10:42] (arrayfunction(a,b))[42]
The parentheses in the last example are required. See Section 8.15 for more about arrays.
4.2.4. Field Selection
If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing
expression.fieldname
In general the row expression must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:
mytable.mycolumn $1.somecolumn (rowfunction(a,b)).col3
(Thus, a qualified column reference is actually just a special case of the field selection syntax.) An important special case is extracting a field from a table column that is of a composite type:
(compositecol).somefield (mytable.compositecol).somefield
The parentheses are required here to show that compositecol is a column name not a table name, or that mytable is a table name not a schema name in the second case.
You can ask for all fields of a composite value by writing .*:
(compositecol).*
This notation behaves differently depending on context; see Section 8.16.5 for details.
4.2.5. Operator Invocations
There are two possible syntaxes for an operator invocation:
expression operator expression (binary infix operator)
44


SQL Syntax
operator expression (unary prefix operator)
where the operator token follows the syntax rules of Section 4.1.3, or is one of the key words AND, OR, and NOT, or is a qualified operator name in the form:
OPERATOR(schema.operatorname)
Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. Chapter 9 describes the built-in operators.
4.2.6. Function Calls
The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:
function_name ([expression [, expression ... ]] )
For example, the following computes the square root of 2:
sqrt(2)
The list of built-in functions is in Chapter 9. Other functions can be added by the user.
When issuing queries in a database where some users mistrust other users, observe security precautions from Section 10.3 when writing function calls.
The arguments can optionally have names attached. See Section 4.3 for details.
Note
A function that takes a single argument of composite type can optionally be called using fieldselection syntax, and conversely field selection can be written in functional style. That is, the notations col(table) and table.col are interchangeable. This behavior is not SQLstandard but is provided in PostgreSQL because it allows use of functions to emulate “computed fields”. For more information see Section 8.16.5.
4.2.7. Aggregate Expressions
An aggregate expression represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:
aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ] aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ] aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]
where aggregate_name is a previously defined aggregate (possibly qualified with a schema name) and expression is any value expression that does not itself contain an aggregate expression or
45


SQL Syntax
a window function call. The optional order_by_clause and filter_clause are described below.
The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since ALL is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the count(*) aggregate function. The last form is used with ordered-set aggregate functions, which are described below.
Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.
For example, count(*) yields the total number of input rows; count(f1) yields the number of input rows in which f1 is non-null, since count ignores nulls; and count(distinct f1) yields the number of distinct non-null values of f1.
Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, min produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as array_agg and string_agg) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional order_by_clause can be used to specify the desired ordering. The order_by_clause has the same syntax as for a query-level ORDER BY clause, as described in Section 7.5, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:
SELECT array_agg(a ORDER BY b DESC) FROM table;
When dealing with multiple-argument aggregate functions, note that the ORDER BY clause goes after all the aggregate arguments. For example, write this:
SELECT string_agg(a, ',' ORDER BY a) FROM table;
not this:
SELECT string_agg(a ORDER BY a, ',') FROM table; -- incorrect
The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two ORDER BY keys (the second one being rather useless since it's a constant).
If DISTINCT is specified in addition to an order_by_clause, then all the ORDER BY expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the DISTINCT list.
Note
The ability to specify both DISTINCT and ORDER BY in an aggregate function is a PostgreSQL extension.
Placing ORDER BY within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called ordered-set aggregates for which an order_by_clause is required, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the order_by_clause is written inside
46


SQL Syntax
WITHIN GROUP (...), as shown in the final syntax alternative above. The expressions in the order_by_clause are evaluated once per input row just like regular aggregate arguments, sorted as per the order_by_clause's requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-WITHIN GROUP order_by_clause, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding WITHIN GROUP, if any, are called direct arguments to distinguish them from the aggregated arguments listed in the order_by_clause. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by GROUP BY; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just () not (*). (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)
An example of an ordered-set aggregate call is:
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households; percentile_cont ----------------50489
which obtains the 50th percentile, or median, value of the income column from table households. Here, 0.5 is a direct argument; it would make no sense for the percentile fraction to be a value varying across rows.
If FILTER is specified, then only the input rows for which the filter_clause evaluates to true are fed to the aggregate function; other rows are discarded. For example:
SELECT count(*) AS unfiltered, count(*) FILTER (WHERE i < 5) AS filtered FROM generate_series(1,10) AS s(i); unfiltered | filtered ------------+---------10 | 4 (1 row)
The predefined aggregate functions are described in Section 9.21. Other aggregate functions can be added by the user.
An aggregate expression can only appear in the result list or HAVING clause of a SELECT command. It is forbidden in other clauses, such as WHERE, because those clauses are logically evaluated before the results of aggregates are formed.
When an aggregate expression appears in a subquery (see Section 4.2.11 and Section 9.23), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and filter_clause if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or HAVING clause applies with respect to the query level that the aggregate belongs to.
4.2.8. Window Function Calls
A window function call represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike non-window aggregate calls, this is not tied to grouping of the
47


SQL Syntax
selected rows into a single output row — each row remains separate in the query output. However the window function has access to all the rows that would be part of the current row's group according to the grouping specification (PARTITION BY list) of the window function call. The syntax of a window function call is one of the following:
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition ) function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
where window_definition has the syntax
[ existing_window_name ]
[ PARTITION BY expression [, ...] ] [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ] [ frame_clause ]
The optional frame_clause can be one of
{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]
where frame_start and frame_end can be one of
UNBOUNDED PRECEDING offset PRECEDING CURRENT ROW offset FOLLOWING UNBOUNDED FOLLOWING
and frame_exclusion can be one of
EXCLUDE CURRENT ROW EXCLUDE GROUP EXCLUDE TIES EXCLUDE NO OTHERS
Here, expression represents any value expression that does not itself contain window function calls.
window_name is a reference to a named window specification defined in the query's WINDOW clause. Alternatively, a full window_definition can be given within parentheses, using the same syntax as for defining a named window in the WINDOW clause; see the SELECT reference page for details. It's worth pointing out that OVER wname is not exactly equivalent to OVER (wname ...); the latter implies copying and modifying the window definition, and will be rejected if the referenced window specification includes a frame clause.
The PARTITION BY clause groups the rows of the query into partitions, which are processed separately by the window function. PARTITION BY works similarly to a query-level GROUP BY clause,
48


SQL Syntax
except that its expressions are always just expressions and cannot be output-column names or numbers. Without PARTITION BY, all rows produced by the query are treated as a single partition. The ORDER BY clause determines the order in which the rows of a partition are processed by the window function. It works similarly to a query-level ORDER BY clause, but likewise cannot use output-column names or numbers. Without ORDER BY, rows are processed in an unspecified order.
The frame_clause specifies the set of rows constituting the window frame, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in RANGE, ROWS or GROUPS mode; in each case, it runs from the frame_start to the frame_end. If frame_end is omitted, the end defaults to CURRENT ROW.
A frame_start of UNBOUNDED PRECEDING means that the frame starts with the first row of the partition, and similarly a frame_end of UNBOUNDED FOLLOWING means that the frame ends with the last row of the partition.
In RANGE or GROUPS mode, a frame_start of CURRENT ROW means the frame starts with the current row's first peer row (a row that the window's ORDER BY clause sorts as equivalent to the current row), while a frame_end of CURRENT ROW means the frame ends with the current row's last peer row. In ROWS mode, CURRENT ROW simply means the current row.
In the offset PRECEDING and offset FOLLOWING frame options, the offset must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the offset depends on the frame mode:
• In ROWS mode, the offset must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.
• In GROUPS mode, the offset again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of peer groups before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the ORDER BY ordering. (There must be an ORDER BY clause in the window definition to use GROUPS mode.)
• In RANGE mode, these options require that the ORDER BY clause specify exactly one column. The offset specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the offset expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an interval. For example, if the ordering column is of type date or timestamp, one could write RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING. The offset is still required to be non-null and non-negative, though the meaning of “non-negative” depends on its data type.
In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.
Notice that in both ROWS and GROUPS mode, 0 PRECEDING and 0 FOLLOWING are equivalent to CURRENT ROW. This normally holds in RANGE mode as well, for an appropriate data-type-specific meaning of “zero”.
The frame_exclusion option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. EXCLUDE CURRENT ROW excludes the current row from the frame. EXCLUDE GROUP excludes the current row and its ordering peers from the frame. EXCLUDE TIES excludes any peers of the current row from the frame, but not the current row itself. EXCLUDE NO OTHERS simply specifies explicitly the default behavior of not excluding the current row or its peers.
The default framing option is RANGE UNBOUNDED PRECEDING, which is the same as RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. With ORDER BY, this sets the frame to be all rows from the partition start up through the current row's last ORDER BY peer. Without
49


SQL Syntax
ORDER BY, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.
Restrictions are that frame_start cannot be UNBOUNDED FOLLOWING, frame_end cannot be UNBOUNDED PRECEDING, and the frame_end choice cannot appear earlier in the above list of frame_start and frame_end options than the frame_start choice does — for example RANGE BETWEEN CURRENT ROW AND offset PRECEDING is not allowed. But, for example, ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING is allowed, even though it would never select any rows.
If FILTER is specified, then only the input rows for which the filter_clause evaluates to true are fed to the window function; other rows are discarded. Only window functions that are aggregates accept a FILTER clause.
The built-in window functions are described in Table 9.64. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)
The syntaxes using * are used for calling parameter-less aggregate functions as window functions, for example count(*) OVER (PARTITION BY x ORDER BY y). The asterisk (*) is customarily not used for window-specific functions. Window-specific functions do not allow DISTINCT or ORDER BY to be used within the function argument list.
Window function calls are permitted only in the SELECT list and the ORDER BY clause of the query.
More information about window functions can be found in Section 3.5, Section 9.22, and Section 7.2.5.
4.2.9. Type Casts
A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:
CAST ( expression AS type ) expression::type
The CAST syntax conforms to SQL; the syntax with :: is historical PostgreSQL usage.
When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in Section 4.1.2.7. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).
An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked “OK to apply implicitly” in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.
It is also possible to specify a type cast using a function-like syntax:
typename ( expression )
However, this only works for types whose names are also valid as function names. For example, double precision cannot be used this way, but the equivalent float8 can. Also, the names in
50


SQL Syntax
terval, time, and timestamp can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided.
Note
The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the “function-like syntax” is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see CREATE CAST.
4.2.10. Collation Expressions
The COLLATE clause overrides the collation of an expression. It is appended to the expression it applies to:
expr COLLATE collation
where collation is a possibly schema-qualified identifier. The COLLATE clause binds tighter than operators; parentheses can be used when necessary.
If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.
The two common uses of the COLLATE clause are overriding the sort order in an ORDER BY clause, for example:
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
and overriding the collation of a function or operator call that has locale-sensitive results, for example:
SELECT * FROM tbl WHERE a > 'foo' COLLATE "C";
Note that in the latter case the COLLATE clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the COLLATE clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit COLLATE clause will override the collations of all other arguments. (Attaching non-matching COLLATE clauses to more than one argument, however, is an error. For more details see Section 24.2.) Thus, this gives the same result as the previous example:
SELECT * FROM tbl WHERE a COLLATE "C" > 'foo';
But this is an error:
SELECT * FROM tbl WHERE (a > 'foo') COLLATE "C";
because it attempts to apply a collation to the result of the > operator, which is of the non-collatable data type boolean.
51


SQL Syntax
4.2.11. Scalar Subqueries
A scalar subquery is an ordinary SELECT query in parentheses that returns exactly one row with one column. (See Chapter 7 for information about writing queries.) The SELECT query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also Section 9.23 for other expressions involving subqueries.
For example, the following finds the largest city population in each state:
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;
4.2.12. Array Constructors
An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word ARRAY, a left square bracket [, a list of expressions (separated by commas) for the array element values, and finally a right square bracket ]. For example:
SELECT ARRAY[1,2,3+4]; array --------{1,2,7} (1 row)
By default, the array element type is the common type of the member expressions, determined using the same rules as for UNION or CASE constructs (see Section 10.5). You can override this by explicitly casting the array constructor to the desired type, for example:
SELECT ARRAY[1,2,22.7]::integer[]; array ---------{1,2,23} (1 row)
This has the same effect as casting each expression to the array element type individually. For more on casting, see Section 4.2.9.
Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word ARRAY can be omitted. For example, these produce the same result:
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]]; array --------------{{1,2},{3,4}} (1 row)
SELECT ARRAY[[1,2],[3,4]]; array --------------{{1,2},{3,4}} (1 row)
52


SQL Syntax
Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions. Any cast applied to the outer ARRAY constructor propagates automatically to all the inner constructors.
Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-ARRAY construct. For example:
CREATE TABLE arr(f1 int[], f2 int[]);
INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr; array -----------------------------------------------{{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}} (1 row)
You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:
SELECT ARRAY[]::integer[]; array ------{} (1 row)
It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word ARRAY followed by a parenthesized (not bracketed) subquery. For example:
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%'); array -----------------------------------------------------------------{2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412} (1 row)
SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i)); array ---------------------------------{{1,2},{2,4},{3,6},{4,8},{5,10}} (1 row)
The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.
The subscripts of an array value built with ARRAY always begin with one. For more information about arrays, see Section 8.15.
4.2.13. Row Constructors
A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word ROW, a left parenthesis, zero or
53


SQL Syntax
more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:
SELECT ROW(1,2.5,'this is a test');
The key word ROW is optional when there is more than one expression in the list.
A row constructor can include the syntax rowvalue.*, which will be expanded to a list of the elements of the row value, just as occurs when the .* syntax is used at the top level of a SELECT list (see Section 8.16.5). For example, if table t has columns f1 and f2, these are the same:
SELECT ROW(t.*, 42) FROM t; SELECT ROW(t.f1, t.f2, 42) FROM t;
Note
Before PostgreSQL 8.2, the .* syntax was not expanded in row constructors, so that writing ROW(t.*, 42) created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without .*, for instance ROW(t, 42).
By default, the value created by a ROW expression is of an anonymous record type. If necessary, it can be cast to a named composite type — either the row type of a table, or a composite type created with CREATE TYPE AS. An explicit cast might be needed to avoid ambiguity. For example:
CREATE TABLE mytable(f1 int, f2 float, f3 text);
CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
-- No cast needed since only one getf1() exists SELECT getf1(ROW(1,2.5,'this is a test')); getf1 ------1 (1 row)
CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
-- Now we need a cast to indicate which function to call: SELECT getf1(ROW(1,2.5,'this is a test')); ERROR: function getf1(record) is not unique
SELECT getf1(ROW(1,2.5,'this is a test')::mytable); getf1 ------1 (1 row)
SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype)); getf1
54


SQL Syntax
------11 (1 row)
Row constructors can be used to build composite values to be stored in a composite-type table column, or to be passed to a function that accepts a composite parameter. Also, it is possible to compare two row values or test a row with IS NULL or IS NOT NULL, for example:
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');
SELECT ROW(table.*) IS NULL FROM table; -- detect all-null rows
For more detail see Section 9.24. Row constructors can also be used in connection with subqueries, as discussed in Section 9.23.
4.2.14. Expression Evaluation Rules
The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.
Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote:
SELECT true OR somefunc();
then somefunc() would (probably) not be called at all. The same would be the case if one wrote:
SELECT somefunc() OR true;
Note that this is not the same as the left-to-right “short-circuiting” of Boolean operators that is found in some programming languages.
As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in WHERE and HAVING clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (AND/OR/NOT combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.
When it is essential to force evaluation order, a CASE construct (see Section 9.18) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a WHERE clause:
SELECT ... WHERE x > 0 AND y/x > 1.5;
But this is safe:
SELECT ... WHERE CASE WHEN x > 0 THEN y/x > 1.5 ELSE false END;
A CASE construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing y > 1.5*x instead.)
CASE is not a cure-all for such issues, however. One limitation of the technique illustrated above is that it does not prevent early evaluation of constant subexpressions. As described in Section 38.7, functions and operators marked IMMUTABLE can be evaluated when the query is planned rather than when it is executed. Thus for example
55


SQL Syntax
SELECT CASE WHEN x > 0 THEN x ELSE 1/0 END FROM tab;
is likely to result in a division-by-zero failure due to the planner trying to simplify the constant subexpression, even if every row in the table has x > 0 so that the ELSE arm would never be entered at run time.
While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an IF-THEN-ELSE statement to protect a risky computation is much safer than just nesting it in a CASE expression.
Another limitation of the same kind is that a CASE cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a SELECT list or HAVING clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:
SELECT CASE WHEN min(employees) > 0 THEN avg(expenses / employees) END FROM departments;
The min() and avg() aggregates are computed concurrently over all the input rows, so if any row has employees equal to zero, the division-by-zero error will occur before there is any opportunity to test the result of min(). Instead, use a WHERE or FILTER clause to prevent problematic input rows from reaching an aggregate function in the first place.
4.3. Calling Functions
PostgreSQL allows functions that have named parameters to be called using either positional or named notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in Section 10.3.
In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.
PostgreSQL also supports mixed notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.
The following examples will illustrate the usage of all three notations, using the following function definition:
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) RETURNS text AS $$ SELECT CASE WHEN $3 THEN UPPER($1 || ' ' || $2) ELSE LOWER($1 || ' ' || $2)
56


SQL Syntax
END; $$ LANGUAGE SQL IMMUTABLE STRICT;
Function concat_lower_or_upper has two mandatory parameters, a and b. Additionally there is one optional parameter uppercase which defaults to false. The a and b inputs will be concatenated, and forced to either upper or lower case depending on the uppercase parameter. The remaining details of this function definition are not important here (see Chapter 38 for more information).
4.3.1. Using Positional Notation
Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:
SELECT concat_lower_or_upper('Hello', 'World', true); concat_lower_or_upper ----------------------HELLO WORLD (1 row)
All arguments are specified in order. The result is upper case since uppercase is specified as true. Another example is:
SELECT concat_lower_or_upper('Hello', 'World'); concat_lower_or_upper ----------------------hello world (1 row)
Here, the uppercase parameter is omitted, so it receives its default value of false, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults.
4.3.2. Using Named Notation
In named notation, each argument's name is specified using => to separate it from the argument expression. For example:
SELECT concat_lower_or_upper(a => 'Hello', b => 'World'); concat_lower_or_upper ----------------------hello world (1 row)
Again, the argument uppercase was omitted so it is set to false implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:
SELECT concat_lower_or_upper(a => 'Hello', b => 'World', uppercase => true); concat_lower_or_upper ----------------------HELLO WORLD (1 row)
57


SQL Syntax
SELECT concat_lower_or_upper(a => 'Hello', uppercase => true, b => 'World'); concat_lower_or_upper ----------------------HELLO WORLD (1 row)
An older syntax based on ":=" is supported for backward compatibility:
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World'); concat_lower_or_upper ----------------------HELLO WORLD (1 row)
4.3.3. Using Mixed Notation
The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:
SELECT concat_lower_or_upper('Hello', 'World', uppercase => true); concat_lower_or_upper ----------------------HELLO WORLD (1 row)
In the above query, the arguments a and b are specified positionally, while uppercase is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.
Note
Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).
58


Chapter 5. Data Definition
This chapter covers how one creates the database structures that will hold one's data. In a relational database, the raw data is stored in tables, so the majority of this chapter is devoted to explaining how tables are created and modified and what features are available to control what data is stored in the tables. Subsequently, we discuss how tables can be organized into schemas, and how privileges can be assigned to tables. Finally, we will briefly look at other features that affect the data storage, such as inheritance, table partitioning, views, functions, and triggers.
5.1. Table Basics
A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable — it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in Chapter 7. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.
Each column has a data type. The data type constrains the set of possible values that can be assigned to a column and assigns semantics to the data stored in the column so that it can be used for computations. For instance, a column declared to be of a numerical type will not accept arbitrary text strings, and the data stored in such a column can be used for mathematical computations. By contrast, a column declared to be of a character string type will accept almost any kind of data but it does not lend itself to mathematical calculations, although other operations such as string concatenation are available.
PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to Chapter 8. Some of the frequently used data types are integer for whole numbers, numeric for possibly fractional numbers, text for character strings, date for dates, time for time-of-day values, and timestamp for values containing both date and time.
To create a table, you use the aptly named CREATE TABLE command. In this command you specify at least a name for the new table, the names of the columns and the data type of each column. For example:
CREATE TABLE my_first_table ( first_column text, second_column integer );
This creates a table named my_first_table with two columns. The first column is named first_column and has a data type of text; the second column has the name second_column and the type integer. The table and column names follow the identifier syntax explained in Section 4.1.1. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.
Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:
CREATE TABLE products ( product_no integer, name text, price numeric
59


Data Definition
);
(The numeric type can store fractional components, as would be typical of monetary amounts.)
Tip
When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.
There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.
If you no longer need a table, you can remove it using the DROP TABLE command. For example:
DROP TABLE my_first_table; DROP TABLE products;
Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the DROP TABLE IF EXISTS variant to avoid the error messages, but this is not standard SQL.)
If you need to modify a table that already exists, see Section 5.6 later in this chapter.
With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to Chapter 6 and read the rest of this chapter later.
5.2. Default Values
A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in Chapter 6.)
If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.
In a table definition, default values are listed after the column data type. For example:
CREATE TABLE products ( product_no integer, name text, price numeric DEFAULT 9.99 );
The default value can be an expression, which will be evaluated whenever the default value is inserted (not when the table is created). A common example is for a timestamp column to have a default of CURRENT_TIMESTAMP, so that it gets set to the time of row insertion. Another common example is generating a “serial number” for each row. In PostgreSQL this is typically done by something like:
60


Data Definition
CREATE TABLE products (
product_no integer DEFAULT nextval('products_product_no_seq'), ... );
where the nextval() function supplies successive values from a sequence object (see Section 9.17). This arrangement is sufficiently common that there's a special shorthand for it:
CREATE TABLE products ( product_no SERIAL, ... );
The SERIAL shorthand is discussed further in Section 8.1.4.
5.3. Generated Columns
A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.
To create a generated column, use the GENERATED ALWAYS AS clause in CREATE TABLE, for example:
CREATE TABLE people ( ..., height_cm numeric,
height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED );
The keyword STORED must be specified to choose the stored kind of generated column. See CREATE TABLE for more details.
A generated column cannot be written to directly. In INSERT or UPDATE commands, a value cannot be specified for a generated column, but the keyword DEFAULT may be specified.
Consider the differences between a column with a default and a generated column. The column default is evaluated once when the row is first inserted if no other value was provided; a generated column is updated whenever the row changes and cannot be overridden. A column default may not refer to other columns of the table; a generation expression would normally do so. A column default can use volatile functions, for example random() or functions referring to the current time; this is not allowed for generated columns.
Several restrictions apply to the definition of generated columns and tables involving generated columns:
• The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.
• A generation expression cannot reference another generated column.
• A generation expression cannot reference a system column, except tableoid.
• A generated column cannot have a column default or an identity definition.
61


Data Definition
• A generated column cannot be part of a partition key.
• Foreign tables can have generated columns. See CREATE FOREIGN TABLE for details.
• For inheritance and partitioning:
• If a parent column is a generated column, its child column must also be a generated column; however, the child column can have a different generation expression. The generation expression that is actually applied during insert or update of a row is the one associated with the table that the row is physically in. (This is unlike the behavior for column defaults: for those, the default value associated with the table named in the query applies.)
• If a parent column is not a generated column, its child column must not be generated either.
• For inherited tables, if you write a child column definition without any GENERATED clause in CREATE TABLE ... INHERITS, then its GENERATED clause will automatically be copied from the parent. ALTER TABLE ... INHERIT will insist that parent and child columns already match as to generation status, but it will not require their generation expressions to match.
• Similarly for partitioned tables, if you write a child column definition without any GENERATED clause in CREATE TABLE ... PARTITION OF, then its GENERATED clause will automatically be copied from the parent. ALTER TABLE ... ATTACH PARTITION will insist that parent and child columns already match as to generation status, but it will not require their generation expressions to match.
• In case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns. If they do not all have the same generation expression, then the desired expression for the child must be specified explicitly.
Additional considerations apply to the use of generated columns.
• Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to arrange it so that a particular role can read from a generated column but not from the underlying base columns.
• Generated columns are, conceptually, updated after BEFORE triggers have run. Therefore, changes made to base columns in a BEFORE trigger will be reflected in generated columns. But conversely, it is not allowed to access generated columns in BEFORE triggers.
5.4. Constraints
Data types are a way to limit the kind of data that can be stored in a table. For many applications, however, the constraint they provide is too coarse. For example, a column containing a product price should probably only accept positive values. But there is no standard data type that accepts only positive numbers. Another issue is that you might want to constrain column data with respect to other columns or rows. For example, in a table containing product information, there should be only one row for each product number.
To that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.
5.4.1. Check Constraints
A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:
62