# java native方法及JNI实例

**前言**

今天在读java.lang.Object 源码中时发现一个

一个hashCode方法：

|1|`public` `native` `int` `hashCode()`|
| ---| -----|

原因Java很好，使用的人很多、应用极广，但是Java不是完美的。Java的不足体现在运行速度要比传统的C++慢上许多之外，还有Java无法直接访问到操作系统底层如硬件系统，为此Java提供了JNI来实现对于底层的访问。JNI，Java Native Interface，它是Java的SDK一部分，JNI允许Java代码使用以其他语言编写的代码和代码库，本地程序中的函数也可以调用Java层的函数，即JNI实现了Java和本地代码间的双向交互。

# 认识 native 即 JNI,Java Native Interface

**Native**

JDK开放给用户的源码中随处可见Native方法，被Native关键字声明的方法说明该方法不是以Java语言实现的，而是以本地语言实现的，Java可以直接拿来用。这里有一个概念，就是本地语言，本地语言这四个字，个人理解应该就是可以和操作系统直接交互的语言。

Java平台有个用户和本地C代码进行互操作的API，称为Java Native Interface (Java本地接口)。

![](0.6196555315391772-20220831220614-yfyyhhy.png)​

# 用 Java 调用 C 写的方法

    我们需要按照下班方便的步骤进行：

    **1、创建一个Java类** ，里面包含着一个 native 的方法和加载库的方法 loadLibrary。HelloNative.java 代码如下：

|123456789101112131415|`public` `class` `HelloNative``{``    ``static``    ``{``        ``System.loadLibrary(``"HelloNative"``);``    ``}``     ` `    ``public` `static` `native` `void` `sayHello();``     ` `    ``@SuppressWarnings``(``"static-access"``)``    ``public` `static` `void` `main(String[] args)``    ``{``        ``new` `HelloNative().sayHello();``    ``}``}`|
| -----------------------| --------------|

     首先大家注意的是native方法，那个加载库的到后面也起作用。native 关键字告诉编译器（其实是JVM）调用的是该方法在外部定义，这里指的是C。如果大家直接运行这个代码，  JVM会告之：“A Java Exception has occurred.”控制台输出如下：

|12345|`Exception in thread<span> </span>``"main"` `java.lang.UnsatisfiedLinkError: no HelloNative in java.library.path``    ``at java.lang.ClassLoader.loadLibrary(Unknown Source)``    ``at java.lang.Runtime.loadLibrary0(Unknown Source)``    ``at java.lang.System.loadLibrary(Unknown Source)``    ``at HelloNative.<clinit>(HelloNative.java:``5`  `这是程序使用它的时候，虚拟机说不知道如何找到sayHello。下面既可以手动写，自然泥瓦匠是用`|
| -------| -----|

 **    2、运行javah** ，得到包含该方法的C声明**头文件.h**

    泥瓦匠将HelloNative.java ，简单地 javac javah，如图

![](0.5356327507922307-20220831220614-egfn9ik.png)​

    就得到了下面的  **HelloNative.h文件 ** ：

|123456789101112131415161718192021|`/* DO NOT EDIT THIS FILE - it is machine generated */``#include <jni.h>``/* Header for class HelloNative */`` ` `#ifndef _Included_HelloNative``#define _Included_HelloNative``#ifdef __cplusplus``extern<span> </span>``"C"` `{``#endif``/*`` ``* Class:     HelloNative`` ``* Method:    sayHello`` ``* Signature: ()V`` ``*/``JNIEXPORT<span> </span>``void` `JNICALL Java_HelloNative_sayHello``  ``(JNIEnv *, jclass);`` ` `#ifdef __cplusplus``}``#endif``#endif`|
| -----------------------------------| ------|

    jni.h 这个文件，在/%JAVA_HOME%include

    3、根据头文件，写 **C实现本地方法** 。

    这里我们简单地实现这个sayHello方法如下：

|1234567|`#include<span> </span>``"HelloNative.h"``#include <stdio.h>`` ` `JNIEXPORT<span> </span>``void` `JNICALL Java_HelloNative_sayHello``{``    ``printf(``"Hello，JNI"``);  ``}`|
| ---------| ----|

    **4、生成dll共享库** ，然后Java程序load库，**调用**即可。

   在Windows上，MinGW GCC 运行如下

|1|`gcc -m64  -Wl,--add-stdcall-alias -I``"C:\Program Files\Java\jdk1.7.0_71\include"` `-I``"C:\Program Files\Java\jdk1.7.0_71\include\include\win32"` `-shared -o HelloNative.dll HelloNative.c`|
| ---| ----|

   -m64表示生成dll库是64位的。然后运行 **HelloNative：  
**

|1|`java HelloNative`|
| ---| --|

   终于成功地可以看到控制台打印如下：

|1|`Hello，JNI`|
| ---| --|

# JNI 调用 C 流程图

![](0.5153753789394342-20220831220614-i2gotu0.png)​

转载地址：http://www.cnblogs.com/Alandre/p/4456719.html

参考地址：http://blog.csdn.net/xw13106209/article/details/6989415

http://www.cnblogs.com/xrq730/p/4824024.html
