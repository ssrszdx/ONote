# 打孔带编程

打孔纸带编程本质上就是基于机器码的程序，虽然看起来很神秘但是其本质并没有什么难理解的。

看到你的标签里有写汇编，那么在这里假设你会一点汇编基础，讲个小例子好了

假定现在有一个CPU，其指令包括：

mov,add,and,or,xor,sub,shift,load,store,halt一共10个指令，对应的值分别是二进制的 0000 到 1001

同时，CPU带有8个寄存器（r)，分别对应了二进制的 0000 到 0111（r0 - r7 )

那么，我们来设想这样一段程序

第一步，将一个内存地址(例如 0x1a)放到寄存器0
第二步，寄存器0的地址所对应的数据读取到寄存器1
第三步，将另一个内存地址(例如0x2c)放到寄存器0
第四步，将寄存器0的地址所对应的数据读取到寄存器2
第五步，将寄存器1和寄存器2的数值相加，存储到寄存器3
第六步，将第三个地址（例如0x3e）放到寄存器0
第四步，将寄存器3的数值写入寄存器0所对应的地址

那么我们的基本的汇编代码看起来应该是
#0 mov r0 0x1a
#1 load r1 [r0]
#2 mov r0 0x2c
#3 load r2 [r0]
#4 add r3 r1 r2
#5 mov r0 0x3e
#6 store r3 [r0]
#7 halt

那么我们来试着把这些翻译成二进制数值

上面知道了有10个指令，同时这些指令也会带有自己的固定参数，我们以二进制每16位为一组做成编码，根据指令规范

mov: 0001 xxxx yyyy yyyy
load: 1000 xxxx yyyy 0000
add: 0010 xxxx yyyy zzzz
store: 1001 xxxx yyyy yyyy
halt: 0000 0000 0000 0000

其中 xxxx yyyy zzzz分别代表了代码中要写的具体数值，

于是翻译过去，就变成了
#0 0001 0000 0001 1010 - mov r0 0x1a
#1 1000 0001 0000 0000 - load r1 [r0]
#2 0001 0000 0010 1100 - mov r0 0x2c
#3 1000 0010 0000 0000 - load r2 [r0]
#4 0010 0011 0001 0010 - add r3 r1 r2
#5 0001 0000 0011 1110 - mov r0 0x3e
#6 1001 0011 0000 0000 - store r3 [r0]
#7 0000 0000 0000 0000 - halt

于是一个汇编代码就可以简单的翻译成纯粹的二进制格式，那么现在可以说一下纸带了

纸带的每一行规定为8个孔位，可以打孔也不打，其中打孔代表1，不打代表0
换而言之，纸带每一行是8个bit，两行也就是16个bit

上面那段二进制的代码，以每8位一行表现到纸带上，我用●表示打孔，○表示没有，那么就变成了
○○○●○○○○ 00010000
○○○●●○●○ 00011010
●○○○○○○● 10000001
○○○○○○○○
.....
不全部写了，大概就是这个样子

打孔纸带的原理就是这个，在这之前和在这之后编程的核心思想其实都没有什么变化，或者说冯氏架构的基本编程思路都在其中了

# 纸带上的孔怎么被计算机识别

**纸带上打的空我知道是代表着符号，关键是他怎么被电脑识别呢？毕竟纸带终归是纸带啊，它不是什么电子元件，怎么能够被电脑识别呢？就好像现在一条纸带我要怎么让他被电脑识别呢？？求...**​[展开]()

很简单的 只是没见过 才感到很奇怪 我举2个简单例子
1、在纸的一边放一个光源，另一半放一个接收器 纸条运动时，但有孔的位置到光源处时，光源会穿过纸条被接收器接收，没孔的位置就会被挡住
2、在2片接触式电极中间夹一个纸条，有孔的位置，电极会接通，没孔的位置电极就断开了
