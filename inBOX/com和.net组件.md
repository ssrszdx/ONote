# com和.net组件

在工作中，有时候用到了引用的组件，测试后，问题就出来了：

　　1.有的发布后总是提示找不到组件（com组件）；

　　2.有的有版本问题（com组件：office导出word时用2003的com，2007下导出有问题）；

　　3.有的提示未能加载程序集（。net组件：GAC和安装路径下都找不到指定程序集）；

　　让我很糊涂，不知道.net 组件和com组件的关系，后来就网上查找，请教，讨论，结果如下：

　　COM组件注册是指Windows编程中，为了使用自定义或第三方COM对象，对进程内组件（DLL）和进程外组件（EXE），利用自注册（self-registering）和非自注册组件程序而进行的操作。COM组件是微软曾经力推了很多年的一种代码复用的技术框架，在这些年里也得到了极大的发展和应用，但它的弊端却也日益明显，我们不得不面对众多的 COM组件之间的版本控制和令人恐怖的DLL地狱，还有注册表、GUID等等。在我们安装一个软件的同时，也带来了大量的我们所未知的版本繁多的COM组件到我们的操作系统中。下面以进程内服务器为例来说明COM组件的调用过程：

　　(1)客户程序先通过调用一个COM API函数CoInitialize()来完成初始化，获得进程的ID号；
　　(2)客户程序通过调用COM API函数CoGet—ClassObject()来获得类工厂接口指针，类工厂用来创建和删除组件对象(又称COM对象)，服务器必须为它的每一个组件提供一个类工厂，在创建组件对象前，必须先创建该组件的类工厂，由类工厂再创建组件对象；① 先查找注册表，发现是进程内服务器，找到对应的动态链接库(DLL)加载，然后调用DUGetclassObject()函数；② 由DllGetclassObject()函数产生对应的类工厂，得到类工厂接口指针，再返回给coGetclassObject()；
　　(3)客户程序通过类工厂接口指针调用Cre—atelnstance()函数创建组件对象实例，并得到对应的接口指针；
　　(4)由接口指针调用相应的方法，实现组件的功能调用；
　　(5)释放类工厂指针和组件对象接口指针；
　　(6)调用CoUninitialize()终止COM系统。

　　使用时必须要注册， 在使用.net中注册组件，有三种方式：

　　１.手动注册： win9x/NT/2000系统提供一个用于注册进程内组件的实用工具sRegSsvr32.exe，如regsvr32 c:\test.dll；在.NET下面，注册.NET组件就需要regasm命令了，如C:\＞regasm out ClassLibrary1.DLL /regfile:ClassLibrary1.reg 。

　　２.编程注册：使用registrationhelper类，主要是利用在iregistrationhelper接口中的方法。

　　３.动态注册：是指在执行应用程序过程中，检查安装组件的版本，如组件的正确版本没安装，则在运行时自动安装需要的版本，即自动注册。　　

　　． NET组件技术的目标之一就是改善COM的缺陷，同时维持COM的核心概念，使得组件开发更加简单。

　　．NET组件与COM组件的区别
　　(1)．NET组件具有自描述能力，不依赖于注册表。．NET组件与元数据一起编译，元数据作为编译组件(在．NET中称为Assembly)的一部分进行保存，元数据能够对组件进行详细描述，包括组件的接口、所支持的类型及开发人员添加的自定义信息。由于．NET组件无须在windows注册表中注册，大大简化了．NET应用程序的部署与安装。
　　(2)．NET组件不再有“DLL Hell”问题。同一组件的多个版本可以同时共存。由于．NET组件不像COM组件那样依赖于注册表中的GUID，因此同～组件的多个版本不会产生冲突，．NET应用程序可以通过编辑应用程序配置文件来指定使用哪个版本的DLL。

　　那如何选择哪？这个就根据具体的需求来了。如果你的功能只有一种可供引用，那就只能选那种了，如果你的功能，这两个里边都可以引用的话，就得看你的环境了，如果就是在。net环境下应用，那。net的组件要好些，因为com组件需要注册，有的还有版本问题；如果你也想写个com类似的东西，很标准，安全性高，也要供大家使用，那调用com会好些。

简单的说就是你的托管代码是否允许非托管代码调用。这个涉及到.NET的平台互操作问题。

比如，.net可以调用C\C++写的DLL,也可以操纵MS Office的组件这就称之为互操作(Invoke)。那么如果你也想让C\C++也来调用你的C可以调用C\C++写的DLL,也可以操纵MS Office的组件这就称之为互操作(Invoke)。那么如果你也想让C\C++也来调用你的C#写的程序，此时就需要开放你的类为对COM可见性。

通常的做法是：

`[ComVisible(``true``)]`

`public` `sealed` `class` `MyClass{ ``// 一般来说对COM可见的类都是密封的。`

`     ``[ComVisible(``true``)]`

`     ``public` `.... Foo(...){`

`       ``// to do sth...`

`     ``}`

`}`
