# Spring之AOP由浅入深

1.AOP的作用

　　在OOP中，正是这种分散在各处且与对象核心功能无关的代码（横切代码）的存在，使得模块复用难度增加。AOP则将封装好的对象剖开，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），切面将那些与业务无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。

2.DI 和 IOC 概念

　　依赖注入或控制反转的定义中，调用者不负责被调用者的实例创建工作，该工作由Spring框架中的容器来负责，它通过开发者的配置来判断实例类型，创建后再注入调用者。由于Spring容器负责被调用者实例，实例创建后又负责将该实例注入调用者，因此称为依赖注入。而被调用者的实例创建工作不再由调用者来创建而是由Spring来创建，控制权由应用代码转移到了外部容器，控制权发生了反转，因此称为控制反转。

3.BeanFactory与ApplicationContext

　　ApplicationContext是BeanFactory的子接口，也被称为应用上下文。BeanFactory提供了Spring的配置框架和基本功能，ApplicationContext则添加了更多企业级功能（如国际化的支持），他另一重要优势在于当ApplicationContext容器初始化完成后，容器中所有的 singleton Bean 也都被实例化了，也就是说当你需要使用singleton Bean 是，在应用中无需等待就可以用，而其他BeanFactory接口的实现类，则会延迟到调用 getBean（）方法时构造，ApplicationContext的初始化时间会稍长些，调用getBean（）是由于Bean已经构造完毕，速度会更快。因此大部分系统都使用ApplicationContext，而只在资源较少的情况下，才考虑使用BeanFactory。

4.AOP的实现策略

（1）Java SE动态代理：
    使用动态代理可以为一个或多个接口在运行期动态生成实现对象，生成的对象中实现接口的方法时可以添加增强代码，从而实现AOP。缺点是只能针对接口进行代理，另外由于动态代理是通过反射实现的，有时可能要考虑反射调用的开销。
（2）字节码生成（CGLib 动态代理）
    动态字节码生成技术是指在运行时动态生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。其常用工具是cglib。
（3）定制的类加载器
    当需要对类的所有对象都添加增强，动态代理和字节码生成本质上都需要动态构造代理对象，即最终被增强的对象是由AOP框架生成，不是开发者new出来的。解决的办法就是实现自定义的类加载器，在一个类被加载时对其进行增强。JBoss就是采用这种方式实现AOP功能。
（4）代码生成
    利用工具在已有代码基础上生成新的代码，其中可以添加任何横切代码来实现AOP。
（5）语言扩展
    可以对构造方法和属性的赋值操作进行增强，AspectJ是采用这种方式实现AOP的一个常见Java语言扩展。

注意：AOP中的切面封装了增强（Advice）和切点（Pointcut），下面先开始只使用增强，切点暂且不加入。

5.编程式增强

　　这里我先用“编程式”的方法，也就是暂且不用Spring的配置文件去定义Bean对象，不把代码中的new操作取代。

（1）创建一个接口和实现类

![](0.1697966511455744-20220205164738-13jifu9.png)

![](0.851293262401009-20220205164738-t2zcd2k.png)

（2）编写前置增强和后置增强（这里我将两个增强合并，即实现两个接口）

![](0.11602482691935934-20220205164738-fib4ebf.png)

（3）JUnit来测试

![](0.05555389053671567-20220205164738-mgz781c.png)

![](0.15035218011547324-20220205164738-ujxami9.png)

（3）环绕增强（当把两个接口合并时，其实完全可以用一个接口就行）

　　环绕增强类需要实现 org.aopalliance.intercept.MethodInterceptor 接口。注意，这个接口不是 Spring 提供的，它是 AOP 联盟写的，Spring 只是借用了它。

![](0.14629466403657054-20220205164738-zy0pvxz.png)

之后再JUnit中添加

![](0.5184786561018506-20220205164738-9e2bw55.png)

6. 声明式增强

　　现在通过Spring配置文件配置bean。同时使用Bean扫描，可以不用在配置文件中配置<bean id="..." class="..."/>.

（1）Spring配置文件（增强类为环绕增强）

![](0.7799314117514429-20220205164738-l6hyv8d.png)

（2）在相应的实现类和增强类上添加Component注解

![](0.5358417327985665-20220205164738-ozpapps.png)

![](0.6401586394280814-20220205164738-kh0rwju.png)

（3）JUnit测试

　　从 Context 中根据 id 获取 Bean 对象（其实就是一个代理），调用代理的方法。

![](0.3433470196441364-20220205164738-qrfmaiz.png)

得到结果

 7.Introduction Advice（引入增强）

　　上面的增强仅仅是对方法增强，也就是织入，对类的增强才能叫做引入增强，比如说我不想让GreetingImpl去直接实现Greeting接口，因为这样的话，我就必须去实现他的方法。这时我就能靠Spring引入增强来帮我动态实现。

（1）定义一个新接口Love

![](0.054156892059790795-20220205164738-4qipc68.png)

（2）定义授权引入增强类

　　定义一个授权引入增强类，实现Love接口，用以丰富GreetingImpl类的功能，这样GreetingImpl就能很巧妙的使用Love接口里的方法而不用去implement。

![](0.019822039604918906-20220205164738-kqrb69i.png)

配置如下：

![](0.03256944023710351-20220205164738-g8pahkp.png)

proxyTargetClass属性表示是否代理目标类，默认是false，也就是代理接口，上面一个例子的配置就是没有这一项属性所以用JDK动态代理，现在是true即使用CGLib动态代理。所以在测试方法中是GreetingImpl greetingImpl = （GreetingImpl）context.getBean（"beans.xml"）,而不会是Greeting greeting = （Greeting）context.getBean（"beans.xml"）,因为现在是代理目标类而不是代理接口。

（3）JUnit测试

![](0.6749786711754913-20220205164738-8b7at5j.png)

![](0.4010423422284979-20220205164738-0g2mjql.png)

注意：这里的Love love = （Love）greetingImpl 是`将目标类强制向上转型为Love接口，`这`就是`引入增强（DelegatingIntroductionInterceptor）的特性--`“接口动态实现”功能`。所以display（）方法可以由GreetingImpl的对象来调用，只需要强制转换接口就行。

8. 面向切面编程

（1）通知（增强）Advice

　　通知定义了切面是什么以及何时使用，应该应用在某个方法被调用之前？之后？还是抛出异常时？等等。

（2）连接点 Join point

　　连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程中，并添加新的行为。

（3）切点 Pointcut

　　切点有助于缩小切面所通知的连接点的范围。如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”，切点会匹配通知所要织入的一个或多个连接点，一般常用正则表达式定义所匹配的类和方法名称来指定这些切点。

（4）切面 Aspect

　　切面是通知和切点的结合。通知和切点定义了切面的全部内容——它是什么，在何时何处完成其功能。

（5）引入 Introduction

　　引入允许我们向现有的类添加新方法或属性，从而无需修改这些现有类的情况下，让他们具有新的行为和状态。

（6）织入 Weaving

　　在过去我常常把织入与引入的概念混淆，我是这样来辨别的，“引入”我把它看做是一个定义，也就是一个名词，而“织入”我把它看做是一个动作，一个动词，也就是切面在指定的连接点被织入到目标对象中。

9.总结一下

　　通知包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知（增强）。创建切点来定义切面所织入的连接点是AOP框架的基本功能。

　　另外，Spring是基于动态代理的，所以Spring只支持方法连接点，而像AspectJ和JBoss除了方法切点，它们还提供字段和构造器接入点。如果需要方法拦截之外的连接点拦截功能，则可以利用AspectJ来补充SpringAOP的功能。

10.使用基于正则表达式的SpringAOP切面类

　　这里使用springAOP的切面类RegexpMethodPointcutAdvisor来配置切面，并在GreetingImpl类中增加两个都以“good”开头的方法，下面要做的就是拦截两个新增方法，而对sayHello（）不拦截。

 ![](0.7701964156240853-20220205164738-nm3mioe.png)

在上面的InterceptorNames属性不再是原来的增强，而是一个定义好的切面greetingAdvisor，切面里面还用正则表达式定义了一个切点，即拦截GreetingImpl类中以good开头的方法。

JUnit测试：

![](0.2429711692779739-20220205164738-ugi6748.png)

![](0.6530385486252708-20220205164738-jgg5dee.png)

 11.AOP自动代理

　（1）Spring框架自动生成代理。

 ![](0.32405477439134955-20220205164738-a90x203.png)

 　　属性optimize意思是对代理生成策略是否优化，true表示如果目标类有接口则代理接口（JDK动态代理），如果没有则代理类（CGLib动态代理），这样便可以取代前面强制代理类的proxyTargetClass属性。

![](0.2478740632291725-20220205164738-m5bkypd.png)

此时因为是自动代理，getBean（）中的值不再是原来代理id（greetingProxy），而是目标类GreetingImpl的Bean的id（greetingImpl），他同样也是一个代理对象。

![](0.4727482970656349-20220205164738-kfubh02.png)

（2）spring根据Bean名称来生成自动代理

![](0.9557607633745646-20220205164738-pnfhd3f.png)

beanNames属性代表只为bean的id后缀是“Impl”生成代理。

12. AspectJ execution 表达式拦截

　　定义一个切面类，实现环绕增强。@Aspect注解就不需要类再实现接口，@Around注解为AspectJ切点表达式，参数ProceedingJoinPoint的对象即为连接点，此连接点可以取得方法名，参数等等。

![](0.5764268596509752-20220205164738-iaeqyni.png)

这样两行配置，节约了配置大量代理和切面的时间，proxy-target-class为true表示代理目标类。

![](0.2419759607678864-20220205164738-0eibpva.png)

之前的切点表达式定义了拦截类中所有方法，所以每个方法都被增强。同时在ApplicationContext中获取的greetingImpl代理对象，可转型为自己静态实现的接口Greeting也可以是实现类GreetingImpl。属性proxy-target-class默认为false，代表只代理接口，也就是说只能将代理转型为Greeting，而不能是GreetingImpl

![](0.7362911606752638-20220205164738-ryguomy.png)

实现类GreetingImpl：

![](0.041028649961454056-20220205164738-3lpfzls.png)

P.s　如果将切面类里的切点从原来的实现类GreetingImpl改为接口Greeting又会发生什么呢？

![](0.23110378136204446-20220205164738-ovj3jr4.png)

改为：

![](0.8308741088234466-20220205164738-zmx4gv9.png)

结果发现，实现类中的实现接口的方法被增强了，而自己创建的good方法没有被增强，这就是因为切点设置为Greeting接口里面所有方法被加强，所以实现了这个接口中的方法被增强了。

![](0.7665776673551699-20220205164738-3qr1xru.png)

13. AspectJ @DeclareParents 注解（引入增强）

　　定义一个切面类AroundAspect：value属性指定了哪种类型的bean要引入该接口。defaultImpl属性指定了为引入功能提供实现的类，@DeclareParents注解所标注的属性指明要引入的接口。

![](0.13089750891174767-20220205164738-av11j50.png)

LoveImpl实现类：将这个实现类引入目标类GreetingImpl中，就能使用display方法。

![](0.04468480549464915-20220205164738-48p4zdh.png)

JUnit测试：

注意：在ApplicationContext中获取的greetingImpl对象是个代理对象，可转型为自己静态实现的接口Greeting，也可以转型为自己动态实现的接口Love，可随意切换。现在的AspectJ的引入增强跟上面的SpringAOP的引入增强只能面向实现类相比，还可面向接口编程。所以有两种方式实现：

![](0.9522170545655997-20220205164738-hc8ok2h.png)

![](0.23867187657417466-20220205164738-u00trlq.png)

控制台输出：

![](0.2574261196219578-20220205164738-6f5xd3u.png)

而对于SpringAOP引入的增强，则只能面向实现类：

![](0.22285995287336124-20220205164738-o52brvn.png)

14.Spring的AspectJ自动代理

　　Spring的AspectJ自动代理仅仅使用@AspectJ作为创建切面的指导，切面依然是基于代理的。在本质上，它依然是Spring基于代理的切面。这意味着尽管使用的是@AspectJ注解，但我们仍然限于代理方法的调用。当Spring发现一个bean使用了@Aspect注解时，Spring就会创建一个代理，然后将调用委托给被代理的bean或被引入的实现，这取决于调用的方法属于被代理的bean还是属于被引入的接口。

15.在XML中声明切面

　　在Spring中，注解和自动代理提供了一种很方便的方式来创建切面，但是面向注解的切面有一个明显的劣势：你必须能够为通知类添加注解，为了这一点，必须要有源码。如果你没有源码的话，或者不想将AspectJ注解放到你的代码之中，Spring提供了另外一种方法，Spring XML 配置文件中声明切面。

　　将前面实现类GreetingImpl和切面类AroundAspect的相关注解@Component，@Aspect，@Around全都移除。编辑XML：

![](0.7926271239483265-20220205164738-1ixu1hf.png)

我们发现原来的两条配置都可以删除，但是要注意，没有显式配置[aop:aspectj-autoproxy/](aop:aspectj-autoproxy/)不代表不使用自动代理，这条配置默认属性为“false”，表示只代理接口（JDK动态代理），所以如果只想代理接口，可以不用显式写出。

![](0.3335020237645827-20220205164738-izad2ho.png)

如果想要使用CGLib动态代理，则增加

![](0.7609882993973471-20220205164738-akzrokj.png)

这时又可以代理目标类了：

![](0.16711004412907116-20220205164738-r1x8bd5.png)

16. END

　　这篇文章是我对《Spring实战》和《AOP那点事儿》的一些知识的整理和例子的实现，希望你也能一起实现一下，如果你觉得还不错的话，请点个赞或关注我，以后会有更多的知识分享！
