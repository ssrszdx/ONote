# 漫画：什么是加密算法

![](0.32109435059546065-20220831222734-aewh0hf.png)​

![](0.811300409231317-20220831222734-5yuc4jo.png)​

![](0.8684813210488882-20220831222734-9xxe9ry.png)​

![](0.23044390631092182-20220831222734-oe4yq5i.png)​

![](0.48291441299655724-20220831222734-lkxct0j.png)​

![](0.6185431912223727-20220831222734-ru11yzi.png)​

**加密算法的历史**

加密算法最早诞生在什么时候？是在计算机出现之后吗？不不不，早在古罗马时期，加密算法就被应用于战争当中。

![](0.9645743433902045-20220831222734-ve6w7y4.png)​

在大规模的战争中，部队之间常常需要信使往来，传递重要的军事情报。

![](0.6461457444105243-20220831222734-nkmfsi9.png)​

可是，一旦信使被敌军抓获，重要的军事情报就完全暴露给了敌方。

![](0.6765211868544196-20220831222734-stwnu1h.png)​

甚至，狡猾的敌人有可能篡改军事情报，并收买信使把假情报传递给我方部队。

![](0.3862221962480996-20220831222734-lnae866.png)​

这样一来，我方部队就完全落入到了敌方的陷阱之中。这种拦截并篡改信息的手法，在网络安全领域被称为 **中间人攻击** 。

怎样防止这种情况的发生呢？不让信使被敌人抓获？这个肯定是无法绝对避免的。

那么我们不妨换个角度，让敌人即使截获了军事情报，也看不懂里面的内容，这就是对信息的 **加密** 。

![](0.6907530045137178-20220831222734-eb85rop.png)​

如何进行加密呢？古人想出了一种非常朴素的加密方法，被称为 **凯撒密码** 。加密的原理就像下图这样：

![](0.8408205438346128-20220831222734-o92y2vj.png)​

如图所示，图中第一行的字母代表信息的“明文”，第二行字母代表信息的密文。这个加密算法十分简单，就是选择一个偏移量（这里的偏移量是2），把明文当中的所有字母按照字母表的顺序向后偏移两位，从而生成密文。比如：

原文的字母 **A** ，对应的密文是字母 **C** 。

原文的字母 **D** ，对应的密文是字母 **F** 。

原文的单词 **Java** ，对应的密文是 **Lcxc** 。

这样一来，敌方看到信使的情报内容，就彻底蒙逼了。相应的，我军事先约定好了密文通信的偏移量，当友军收到情报以后，把密文的所有字母向前偏移两位，就还原成了明文，这个过程叫做 **解密** 。

但是，这种加密方法真的百分百保险吗？并不是。

在英语的26个字母中，出现频率最高的字母是 **e** 。如果敌人截获了情报，发现这段看不懂的密文当中出现频率最高的字母是g，由于e和g相差两个字母，就可以猜测出我军的密文通信很可能选择2作为偏移量。这样一来，我军的密码就被破解了。

最不济，敌人可以把每一种偏移量都尝试一遍（26个字母，最多25种偏移），终究可以试出符合正常语法的偏移量。这种方式被称为 **暴力破解** 。

![](0.30244131028541-20220831222734-t6af5nz.png)​

![](0.39397379375882724-20220831222734-mfci4x8.png)​

**加密算法的种类**

在如今的信息安全领域，有各种各样的加密算法凝聚了计算机科学家门的智慧。从宏观上来看，这些加密算法可以归结为三大类：**哈希算法、对称加密算法、非对称加密算法。**

**1.哈希算法**

从严格意义上来说， **哈希算法并不属于加密算法** ，但它在信息安全领域起到了很重要的作用。

哈希算法能做什么用呢？其中一个重要的作用就是 **生成信息摘要** ，用以验证原信息的完整性和来源的可靠性。

让我们来举个栗子：

在某个互联网应用上，有用户下单买了东西，于是应用需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。

![](0.6737620053773139-20220831222734-b185orb.png)​

支付宝怎么知道这个请求是真的来自该应用，并且没有被篡改呢？

请求的发送方把所有参数，外加双方约定的Key（例子中Key=abc）拼接起来，并利用哈希算法生成了一段信息摘要：

**Hash（1234_100_abc） = 948569CD3466451F**

而请求的接收方在接到参数和摘要之后，按照同样的规则，也把参数和Key拼接起来并生成摘要：

**Hash（1234_100_abc） = 948569CD3466451F**

如果最终发现两端信息摘要一致，证明信息没有被篡改，并且来源确实是该互联网应用。（只要参数修改了一点点，或者Key不一样，那么生成的信息摘要就会完全不同）

生成信息摘要的过程叫做 **签名** ，验证信息摘要的过程叫做 **验签** 。

哈希算法包含哪些具体的算法呢？其中最著名的当属 **MD5算法** 。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了 **SHA系列算法** 。

**2.对称加密算法**

哈希算法可以解决验签的问题，却无法解决明文加密的问题。这时候，就需要真正的加密算法出场了。

什么是对称加密呢？这个概念很好理解：

![](0.5589379718388323-20220831222734-trseklk.png)​

如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。

除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。

对称加密包含哪些具体的算法呢？在早期，人们使用**DES算法**进行加密解密；后来，人们觉得DES不够安全，发明了 **3DES算法** ；而如今，最为流行的对称加密算法是 **AES算法** 。

不知道读者中有多少人曾经接触过欧盟的GDPR法案，为了遵从该法案，有的企业就曾经将数据库中的敏感信息使用3DES进行加密。

总而言之，对称算法的好处是加密解密的效率比较高。相应的，对称算法的缺点是不够安全。为什么呢？通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。

为了解决这一痛点，非对称加密就登场了。

**3.非对称加密算法**

什么又是非对称加密呢？在刚刚接触到的时候，或许你会觉得这种算法有些古怪：

![](0.5110362313086367-20220831222734-865c58j.png)​

如图所示，在非对称加密中存在一对密钥，其中一个叫做 **公钥** ，另一个叫做 **私钥** 。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。

这样设计有什么好处呢？看看通信的过程就知道了：

1.在双方建立通信的时候，服务端只要把公钥告诉给客户端，自己保留私钥。

2.客户端利用获得的公钥。加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。

3.服务端获得消息后，用自己的私钥解密，得到里面隐含的密钥X。

4.从此以后，双方可以利用密钥X进行对称加密的通信了。

![](0.3944223797805353-20220831222734-epvbkyc.png)​

在这个过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。

非对称加密算法的代表有哪些呢？最著名的当属 **RSA算法** 。

既然非对称加密这么强大，是不是没有缺点呢？也不是。非对称加密最大的问题，就是性能较差，无法应用于长期的通信。

![](0.5174801254391377-20220831222734-z3hrl8u.png)​

![](0.4169349010846988-20220831222734-mmuma9q.png)​

如果喜欢本文，请给个好看，觉得特别喜欢，请转发给你的朋友们。

来源： [https://zhuanlan.zhihu.com/p/55574439](https://zhuanlan.zhihu.com/p/55574439)
