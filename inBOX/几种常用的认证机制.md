# 几种常用的认证机制

### **1. ​**​****

HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth

---

### **2. ​**​****

OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。

OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容
下面是OAuth2.0的流程：
![这里写图片描述](0.5233852085841291-20220206104321-x9hrixc.png)
这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用；

---

### **3. Cookie-session Auth**

Cookie-session 认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；
但是这种基于cookie-session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来。

**基于session认证所显露的问题：**

* **Session**
  每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。
* **扩展性**
  用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。
* **CSRF**
  因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击

---

### **4. Token Auth**

基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

**流程：**

* 用户使用用户名密码来请求服务器
* 服务器进行验证用户的信息
* 服务器通过验证发送给用户一个token
* 客户端存储token，并在每次请求时附送上这个token值
* 服务端验证token值，并返回数据

这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持`CORS(跨来源资源共享)`策略，一般我们在服务端这么做就可以了`Access-Control-Allow-Origin`。
![这里写图片描述](0.8369913307633985-20220206104321-jrf9m2x.png)

**Token Auth的优点**

* **支持跨域访问**
  Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.
* **无状态(服务端可扩展行)**
  Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.
* **更适用CDN:**
  可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.
* **去耦:**
  不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.
* **更适用于移动应用**
  当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。
* ****
  因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。
* **性能:**
  一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.
* **不需要为登录页面做特殊处理:**
  如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.
* **基于标准化**
  你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）

**对Token认证的五点认识**

* 一个Token就是一些信息的集合；
* 在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；
* 服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
* 基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
* 因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；

---

### **5. 基于**​****​**的Token认证机制实现**

> JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准[（RFC 7519）](https://tools.ietf.org/html/rfc7519)，定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。
>
> * **简洁(Compact)**
>   可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快
> * **自包含(Self-contained)**
>   负载中包含了所有用户所需要的信息，避免了多次查询数据库

**JWT的主要应用场景**

* **身份认证**
  在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。
* **信息交换**
  在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。

**JWT的结构**

* **Header 头部**
* **Payload 负载**
* **Signature 签名**

**1. Header**

jwt的头部承载两部分信息：

* 声明类型，这里是jwt
* 声明加密的算法 通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.

**2. playload**

载荷就是存放有效信息的地方，这些有效信息包含三个部分：

* **标准中注册的声明(Reserved claims)**
  这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是**推荐使用**

  * **iss:** jwt签发者
  * **sub:** jwt所面向的用户
  * **aud:** 接收jwt的一方
  * **exp:** jwt的过期时间，这个过期时间必须要大于签发时间
  * **nbf:** 定义在什么时间之前，该jwt都是不可用的.
  * **iat:** jwt的签发时间
  * **jti:** jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
* 公共的声明
  公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.
* 私有的声明
  私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

定义一个payload:

然后将其进行base64加密，得到Jwt的第二部分。

**3. signature**

jwt的第三部分是一个签证信息，这个签证信息由三部分组成：

* header (base64后的)
* payload (base64后的)
* secret

这个部分需要base64加密后的header和base64加密后的payload使用 . 连接组成的字符串，然后通过header中声明的加密方式（如：HS256算法）进行加盐secret组合加密，然后就构成了jwt的第三部分。

**注意：**

> secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。

#### **认证过程**

下面我们从一个实例来看如何运用JWT机制实现认证：

**1. 登录**

* 第一次认证：第一次登录，用户从浏览器输入用户名/密码，提交后到服务器的登录处理的Action层（Login Action）；
* Login Action调用认证服务进行用户名密码认证，如果认证通过，Login Action层调用用户信息服务获取用户信息（包括完整的用户信息及对应权限信息）；
* 返回用户信息后，Login Action从配置文件中获取Token签名生成的秘钥信息，进行Token的生成；
* 生成Token的过程中可以调用第三方的JWT Lib生成签名后的JWT数据；
* 完成JWT数据签名后，将其设置到COOKIE对象中，并重定向到首页，完成登录过程；
  ![这里写图片描述](0.1851387725872995-20220206104321-iielpl0.png)

**2. 请求认证**

基于Token的认证机制会在每一次请求中都带上完成签名的Token信息，这个Token信息可能在COOKIE中，也可能在HTTP的Authorization头中；

* 客户端（APP客户端或浏览器）通过GET或POST请求访问资源（页面或调用API）；
* 认证服务作为一个Middleware HOOK 对请求进行拦截，首先在cookie中查找Token信息，如果没有找到，则在HTTP Authorization Head中查找；
* 如果找到Token信息，则根据配置文件中的签名加密秘钥，调用JWT Lib对Token信息进行解密和解码；
* 完成解码并验证签名通过后，对Token中的exp、nbf、aud等信息进行验证；
  全部通过后，根据获取的用户的角色权限信息，进行对请求的资源的权限逻辑判断；
* 如果权限逻辑判断通过则通过Response对象返回；否则则返回HTTP 401；

#### **如何使用JWT**

在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。

当用户希望访问一个受保护的路由或者资源的时候，通常应该在`Authorization`头部使用`Bearer`模式添加JWT，其内容看起来是下面这样：

因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。

JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。

![这里写图片描述](0.5228473365523707-20220206104321-k96nqyt.png)

#### **JWT的JAVA实现**

Java中对JWT的支持可以考虑使用[JJWT开源库](https://github.com/jwtk/jjwt)；JJWT实现了JWT, JWS, JWE 和 JWA RFC规范；下面将简单举例说明其使用：

**生成Token码**

**解码和验证Token码**

#### **基于JWT的Token认证的安全问题**

**1. 确保验证过程的安全性**

如何保证用户名/密码验证过程的安全性；因为在验证过程中，需要用户输入用户名和密码，在这一过程中，用户名、密码等敏感信息需要在网络中传输。因此，在这个过程中建议采用HTTPS，通过SSL加密传输，以确保通道的安全性。

**2. 如何防范**​****

* **XSS攻击代码过滤**
  移除任何会导致浏览器做非预期执行的代码，这个可以采用一些库来实现（如：js下的js-xss，JAVA下的XSS HTMLFilter，PHP下的TWIG）；如果你是将用户提交的字符串存储到数据库的话（也针对SQL注入攻击），你需要在前端和服务端分别做过滤；
* **采用HTTP-Only Cookies**
  通过设置Cookie的参数： HttpOnly; Secure 来防止通过JavaScript 来访问Cookie；
  在Java中设置cookie是HttpOnly，升级[Tomcat7.0，它已经实现了Servlet3.0](http://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/http/Cookie.html)
  或者通过这样来设置：

**3. 如何防范Replay Attacks**

所谓重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程。比如在浏览器端通过用户名/密码验证获得签名的Token被木马窃取。即使用户登出了系统，黑客还是可以利用窃取的Token模拟正常请求，而服务器端对此完全不知道，以为JWT机制是无状态的。

针对这种情况，有几种常用做法可以用作参考：
1、时间戳 +共享秘钥
这种方案，客户端和服务端都需要知道：

* **User ID**
* **共享秘钥**

**客户端**

**服务端**

2、时间戳 +共享秘钥+黑名单 （类似[Zendesk](https://support.zendesk.com/hc/en-us/articles/203663816-Setting-up-single-sign-on-with-JWT-JSON-Web-Token-)的做法）

**客户端**

**服务端**

```
20
```

```
  # 前面的步骤参考上面
```

```
  payload = JWT.decode(request.authorization, nil, false)
```

```
  @current_user = User.find(payload['user_id'])
```

```
  JWT.decode(request.authorization, current_user.api_secret)
```

**4. 如何防范MITM （Man-In-The-Middle）Attacks**

所谓MITM攻击，就是在客户端和服务器端的交互过程被监听，比如像可以上网的咖啡馆的WIFI被监听或者被黑的代理服务器等；
针对这类攻击的办法使用HTTPS，包括针对分布式应用，在服务间传输像cookie这类敏感信息时也采用HTTPS；所以云计算在本质上是不安全的。

---

**参考：**

1. [什么是 JWT – JSON WEB TOKEN](https://www.jianshu.com/p/576dbf44b2ae)
2. [JWT 简介](https://segmentfault.com/a/1190000005047525)
3. [几种常用的认证机制](https://www.cnblogs.com/xiekeli/p/5607107.html)
4. [讲真，别再使用JWT了！](https://www.jianshu.com/p/af8360b83a9f)
