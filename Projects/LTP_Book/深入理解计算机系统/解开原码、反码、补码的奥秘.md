# 解开原码、反码、补码的奥秘

## 原码、反码、补码

根据冯诺依曼的设计，任何存储于计算机中的数据，`都是以二进制码存储`。一个整数（无论正负）在计算机中都会被转换成二进制（ 原码 or 反码 or 补码）。 什么情况下会转化成原码，什么情况下会转化成反码，什么情况下会转化成补码，文章后面会讲。但这一节只会提及怎样转化成原码、反码、补码。

**原码**

> ***原码：*** 是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数绝对值的二进制。

例如`short a = 6;`，a 的原码就是`0000 0000 0000 0110`；更改 a 的值`a = -18;`，此时 a 的原码就是`1000 0000 0001 0010`。

![](https://pic4.zhimg.com/80/v2-2c0ab26bcf344a7b395fcde92e847fd3_1440w.jpg)  
部份正负整数的二进制原码

**反码**

> 正数的反码还是等于原码。负数的反码就是他的原码除符号位外，按位取反。

对于 **正数，它的反码就是其原码** ； **负数的反码是将原码中除符号位以外的所有位（数值位）取反** ，也就是 0 变成 1，1 变成 0。例如`short a = 6;`，a 的原码和反码都是`0000 0000 0000 0110`；更改 a 的值`a = -18;`，此时 a 的反码是`1111 1111 1110 1101`。

![](https://pic4.zhimg.com/80/v2-1aa3f2a250c01a2a20dffd88fbcbbfa7_1440w.jpg)  
部分正负数的二进制数反码表示法

**补码**

> **补码：** 正数的补码等于他的原码。负数的补码等于反码+1。

对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如`short a = 6;`，a 的原码、反码、补码都是`0000 0000 0000 0110`；更改 a 的值`a = -18;`，此时 a 的补码是`1111 1111 1110 1110`。

![](https://pic1.zhimg.com/80/v2-4cc1a77b963467ba01b9148050b8bfc0_1440w.jpg)  
6 和 -18 从原码到补码的转换过程

可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。

## 为什么会有补码

计算机被发明之初就是用来解决加减乘除的运算问题的，人类先是发明了加法器，像这样：

![](https://pic2.zhimg.com/80/v2-200ad63642f282fb0beb28354b0dfcc9_1440w.jpg)

用与非门来实现加法器是一件很自然的事情，这是它们本身的特性。  
如果将乘法看作是累加（移位，逻辑判断，累加），那么加法问题解决了，乘法问题也就解决了。  
那也就是说：如果减法问题解决了，除法问题也就解决了（移位，逻辑判断，累减）。  
所以现在问题就变成了：**计算机如何计算减法？ **其实就是减法变成加法。

假如我们要计算 6 - 18 的结果，它等价于 6 + (-18)。

如果采用原码计算，那么运算过程为：

> 6 - 18 = 6 + (-18)  
> = [0000 0000 0000 0110]原 + [1000 0000 0001 0010]原  
> = [1000 0000 0001 1000]原  
> = -24

直接用原码表示整数，让符号位也参与运算，对于类似上面的减法来说，结果显然是不正确的。

于是人们开始继续探索，不断试错，后来设计出了反码。下面就演示了反码运算的过程：

> 6 - 18 = 6 + (-18)  
> = [0000 0000 0000 0110]反 + [1111 1111 1110 1101]反  
> = [1111 1111 1111 0011]反  
> = [1000 0000 0000 1100]原  
> = -12

这样一来，计算结果就正确了。

然而，这样还不算万事大吉，我们不妨将减数和被减数交换一下位置，也就是计算 18 - 6 的结果：

> 18 - 6 = 18 + (-6)  
> = [0000 0000 0001 0010]反 + [1111 1111 1111 1001]反  
> = [**1** 0000 0000 0000 1011]反  
> = [0000 0000 0000 1011]反  
> = [0000 0000 0000 1011]原  
> = 11

按照反码计算的结果是 11，而真实的结果应该是 12 才对，它们相差了 1。

粗体的 **1** 是加法运算过程中的进位，它溢出了，内存容纳不了了，所以直接截掉。

6 - 18 的结果正确，18 - 6 的结果就不正确，相差 1。按照反码来计算，是不是小数减去大数正确，大数减去小数就不对了，始终相差 1 呢？我们不妨再看两个例子，分别是 5 - 13 和 13 - 5。

5 - 13 的运算过程为：

> 5 - 13 = 5 + (-13)  
> = [0000 0000 0000 0101]原 + [1000 0000 0000 1101]原  
> = [0000 0000 0000 0101]反 + [1111 1111 1111 0010]反  
> = [1111 1111 1111 0111]反  
> = [1000 0000 0000 1000]原  
> = -8

13 - 5 的运算过程为：

> 13 - 5 = 13 + (-5)  
> = [0000 0000 0000 1101]原 + [1000 0000 0000 0101]原  
> = [0000 0000 0000 1101]反 + [1111 1111 1111 1010]反  
> = [**1** 0000 0000 0000 0111]反  
> = [0000 0000 0000 0111]反  
> = [0000 0000 0000 0111]原  
> = 7

这足以证明，刚才的猜想是正确的：小数减去大数不会有问题，而大数减去小数的就不对了，结果始终相差 1。

相差的这个 1 要进行纠正，但是又不能影响小数减去大数，怎么办呢？于是人们又绞尽脑汁设计出了补码，给反码打了一个“补丁”，终于把相差的 1 给纠正过来了。

下面演示了按照补码计算的过程：

> 6 - 18 = 6 + (-18)  
> = [0000 0000 0000 0110]补 + [1111 1111 1110 1110]补  
> = [1111 1111 1111 0100]补  
> = [1111 1111 1111 0011]反  
> = [1000 0000 0000 1100]原  
> = -12
>
> 18 - 6 = 18 + (-6)  
> = [0000 0000 0001 0010]补 + [1111 1111 1111 1010]补  
> = [**1** 0000 0000 0000 1100]补  
> = [0000 0000 0000 1100]补  
> = [0000 0000 0000 1100]反  
> = [0000 0000 0000 1100]原  
> = 12
>
> 5 - 13 = 5 + (-13)  
> = [0000 0000 0000 0101]补 + [1111 1111 1111 0011]补  
> = [1111 1111 1111 1000]补  
> = [1000 1111 1111 0111]反  
> = [1000 0000 0000 1000]原  
> = -8
>
> 13 - 5 = 13 + (-5)  
> = [0000 0000 0000 1101]补 + [1111 1111 1111 1011]补  
> = [**1** 0000 0000 0000 1000]补  
> = [0000 0000 0000 1000]补  
> = [0000 0000 0000 1000]反  
> = [0000 0000 0000 1000]原  
> = 8

你看，采用补码的形式正好把相差的 1 纠正过来，也没有影响到小数减去大数，这个“补丁”真是巧妙。

小数减去大数，结果为负数，之前（负数从反码转换为补码要加 1）加上的 1，后来（负数从补码转换为反码要减 1）还要减去，正好抵消掉，所以不会受影响。

## 有符号数、无符号数

C 语言中整数总体可以分为  **有符号数** (signed) 和  **无符号数** (unsigned)。

无符号数在内存中是以原码存储的，而有符号数的正数是原码存储，有符号的负数是补码存储。（正数的原码、反码、补码都是相同，所以可以理解成， **正负整数都是以补码存储的** ）

举个例子来说，unsigned int a = 1; 变量a在内存中就是以00000000 00000001来存储的。因为这里是unsigned int，它是无符号整型，所以的它的16位全部用来表示数据。

```text
int b = -1;
```

这里情况就稍微有点复杂了，注意数字1和-1在内存中的存储是完全不一样的，整数是以原码的形式存储的，而负数是以**补码**的形式存储的。

计算过程如下：

> 首先1的原码是 00000000 00000001  
> 其次取它的反码是 11111111 11111110  
> 最后在其反码的基础上加上1 11111111 11111111  
> 得到-1的补码是，11111111 11111111

‍

补码表示定点整数时，和原码、反码相比，有以下四个好处：

（1）符号位可以和数值位一起参加运算

（2）可以用加法方便地实现减法运算

（3）零的表示唯一

（4）可以多表示一个最小负数

所以，现代计算机都用补码来表示定点整数。

‍

 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.  
        于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0  
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 。如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0     表达式1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

        发现用反码计算减法, 结果的[真值](https://so.csdn.net/so/search?q=%E7%9C%9F%E5%80%BC&spm=1001.2101.3001.7020)部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 表达式1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原  。这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

接下来我们来看补码运算原理：  
        在计算机里，如果我们要计算5-3的值，我们既可以用5减去3，也可以用5加上13。这是为什么呢？  
这就像我们的钟表，它从1点走到12点之后，又回到了1点。我们的计算机也是，从0走到15之后，再往下走就又回到了0，就像我们转了一个圈一样。我们从5这个位置往回退3个格，就完成了5-3这个计算。我们也可以从5这个位置往前走，一直走到15，这时我们走了10个格，然后我们继续往前走，走到0，然后到1，然后就走到了2。这样，我们往前走了13个格之后，也到了2这个位置。  
        所以说，在我们这个计算机中，减3和加13是一样的。而3+13=16，我们说在模16的系统下，3和13是互补的。  
这样，我们计算5-3就可以换成5+13。3的二进制表示为0011，5的二进制表示为0101。这样，0101-0011就可以表示为0101+（-0011）。  
        我们在计算机中都是把负数用其[补码](https://so.csdn.net/so/search?q=%E8%A1%A5%E7%A0%81&spm=1001.2101.3001.7020)表示，-0011的补码就是10000-0011（即16-3，也就是13）。10000-0011=1+1111-0011=1+（1111-0011）=1+1100=1101。

    我们总说补码是“按位取反再加一”，看了上面这个式子相信大家就会明白了，其实就是把10000-0011换成了1111-0011再加1的形式。然后，0101-0011就换成了0101+1101，它们计算出来的结果为10010。由于我们的计算机只有四个bit，所以结果为0010。即，在模16的计算机中，5-3=5+13=2。
